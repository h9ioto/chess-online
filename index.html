<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∞—Ö–º–∞—Ç—ã</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #262421;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 10px;
            padding-bottom: 60px;
            min-height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }
        
        .container { max-width: 500px; margin: 0 auto; }
        h1 { color: #fff; text-align: center; font-size: 22px; margin-bottom: 15px; }
        
        .menu { background: #1a1816; border-radius: 12px; padding: 20px; margin-bottom: 15px; display: block; }
        .menu.hidden { display: none; }
        .menu-title { color: #81b64c; font-size: 16px; font-weight: 600; margin-bottom: 15px; text-align: center; }
        
        .setting { margin-bottom: 15px; }
        .setting-label { color: #bababa; font-size: 13px; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .setting-value { color: #81b64c; font-weight: 600; }
        
        input[type="range"] { width: 100%; height: 8px; border-radius: 4px; background: #3d3a37; outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 22px; height: 22px; border-radius: 50%; background: #81b64c; cursor: pointer; }
        
        .theme-select, .color-select, .time-select { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; }
        
        .theme-btn, .color-btn, .time-btn {
            padding: 8px 12px;
            border: 2px solid #3d3a37;
            border-radius: 8px;
            background: #262421;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s;
        }
        .theme-btn.active, .color-btn.active, .time-btn.active { border-color: #81b64c; background: rgba(129,182,76,0.15); }
        .theme-btn img, .color-btn img { width: 24px; height: 24px; }
        
        .board-preview {
            width: 36px; height: 36px;
            display: grid; grid-template-columns: 1fr 1fr;
            border-radius: 4px; overflow: hidden;
        }
        .board-preview div { width: 100%; height: 100%; }
        
        .custom-time { display: flex; gap: 10px; align-items: center; justify-content: center; margin-top: 10px; padding: 10px; background: #262421; border-radius: 8px; }
        .custom-time.hidden { display: none; }
        .custom-time label { color: #bababa; font-size: 12px; }
        .custom-time input { width: 50px; padding: 8px; border: none; border-radius: 6px; background: #3d3a37; color: #fff; font-size: 14px; text-align: center; }
        
        .toggle-setting { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; }
        .toggle-setting span { color: #bababa; font-size: 13px; }
        .toggle { width: 44px; height: 24px; background: #3d3a37; border-radius: 12px; position: relative; cursor: pointer; transition: background 0.3s; }
        .toggle.active { background: #81b64c; }
        .toggle::after { content: ''; position: absolute; width: 20px; height: 20px; background: #fff; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .toggle.active::after { transform: translateX(20px); }
        
        .menu-btns { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        
        .btn { padding: 14px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: transform 0.1s; }
        .btn:active { transform: scale(0.97); }
        .btn.green { background: #81b64c; color: #fff; }
        .btn.blue { background: #4a90d9; color: #fff; }
        .btn.orange { background: #d97f4a; color: #fff; }
        .btn.gray { background: #3d3a37; color: #bababa; }
        .btn.red { background: #c0392b; color: #fff; }
        .btn.yellow { background: #f39c12; color: #fff; }
        .btn.purple { background: #9b59b6; color: #fff; }
        .btn.small { padding: 10px 12px; font-size: 12px; }
        
        .online-section { background: #1f1d1b; border-radius: 8px; padding: 15px; margin-top: 15px; }
        .online-title { color: #4a90d9; font-size: 14px; margin-bottom: 10px; }
        .game-link { display: flex; gap: 8px; }
        .game-link input { flex: 1; padding: 12px; border: none; border-radius: 6px; background: #3d3a37; color: #fff; font-size: 14px; }
        .connection-status { text-align: center; font-size: 12px; margin-top: 8px; min-height: 18px; }
        .connection-status.error { color: #e74c3c; }
        .connection-status.success { color: #81b64c; }
        .connection-status.waiting { color: #f39c12; }
        
        .waiting { text-align: center; padding: 30px; color: #bababa; }
        .waiting-spinner { font-size: 50px; animation: spin 2s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .game-screen { display: none; }
        .game-screen.active { display: block; }
        .menu-screen { display: block; }
        .menu-screen.hidden { display: none; }
        
        .player-box { display: flex; align-items: center; padding: 10px 12px; background: #1a1816; border-radius: 8px; margin: 8px 0; }
        .player-box.active { background: #2d2a27; box-shadow: inset 0 0 0 2px #81b64c; }
        .avatar { width: 36px; height: 36px; border-radius: 6px; background: #4a4745; display: flex; align-items: center; justify-content: center; font-size: 20px; margin-right: 12px; flex-shrink: 0; }
        .player-info { flex: 1; min-width: 0; }
        .player-name { color: #fff; font-size: 14px; font-weight: 600; }
        .player-rating { color: #7c7a78; font-size: 12px; }
        .timer { background: #2d2a27; color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 16px; font-weight: bold; font-family: monospace; min-width: 65px; text-align: center; flex-shrink: 0; }
        .timer.low { background: #c0392b; animation: pulse 0.5s infinite; }
        .timer.inactive { background: #1a1816; color: #555; }
        .timer.hidden { display: none; }
        @keyframes pulse { 50% { opacity: 0.7; } }
        .captured { display: flex; flex-wrap: wrap; gap: 1px; margin-left: 8px; }
        .captured img { width: 15px; height: 15px; }
        
        #board { display: grid; grid-template-columns: repeat(8, 1fr); aspect-ratio: 1; border-radius: 4px; overflow: hidden; box-shadow: 0 5px 25px rgba(0,0,0,0.5); max-width: 480px; margin: 0 auto; position: relative; }
        
        .sq { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; position: relative; }
        .sq.sel { background: #f6f669 !important; }
        .sq.lm { background: #f5f682 !important; }
        .sq.ch { background: #eb6a5d !important; animation: check-pulse 0.8s ease-in-out infinite; }
        .sq.premove-from, .sq.premove-to { background: #e74c3c !important; box-shadow: inset 0 0 0 4px #c0392b; }
        .sq.drag-over { box-shadow: inset 0 0 0 4px #81b64c; }
        .sq.dot::after { content: ''; width: 30%; height: 30%; background: rgba(0,0,0,0.15); border-radius: 50%; position: absolute; pointer-events: none; }
        .sq.cap::after { content: ''; width: 100%; height: 100%; border: 5px solid rgba(0,0,0,0.15); border-radius: 50%; position: absolute; box-sizing: border-box; pointer-events: none; }
        .sq img { width: 88%; height: 88%; pointer-events: none; filter: drop-shadow(1px 2px 3px rgba(0,0,0,0.25)); }
        
        @keyframes check-pulse { 0%, 100% { box-shadow: inset 0 0 0 4px #eb6a5d; } 50% { box-shadow: inset 0 0 20px 4px #ff0000; } }
        
        /* –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ */
        .dragging-piece { position: fixed; pointer-events: none; z-index: 2000; transform: translate(-50%, -50%) scale(1.15); filter: drop-shadow(4px 8px 12px rgba(0,0,0,0.5)); }
        .dragging-piece img { width: 100%; height: 100%; }
        .sq.dragging-from { opacity: 0.4; }
        
        /* –ê–Ω–∏–º–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è */
        .piece-animate { position: absolute; pointer-events: none; z-index: 1000; }
        .piece-animate img { width: 100%; height: 100%; filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.4)); }
        
        /* –ê–Ω–∏–º–∞—Ü–∏—è –≤–∑—è—Ç–∏—è */
        @keyframes capture-explode { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.3); opacity: 0.6; } 100% { transform: scale(0); opacity: 0; } }
        @keyframes capture-ring { 0% { transform: scale(0.5); opacity: 1; border-width: 4px; } 100% { transform: scale(2); opacity: 0; border-width: 1px; } }
        .capture-effect { position: absolute; inset: 0; pointer-events: none; z-index: 500; display: flex; align-items: center; justify-content: center; }
        .capture-effect img { animation: capture-explode 0.35s ease-out forwards; }
        .capture-ring { position: absolute; width: 50%; height: 50%; border: 4px solid #ff6b6b; border-radius: 50%; animation: capture-ring 0.4s ease-out forwards; }
        
        /* –ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ç–∞ */
        @keyframes king-fall { 0% { transform: rotate(0deg) scale(1); } 30% { transform: rotate(-15deg) scale(1.1); } 60% { transform: rotate(20deg) scale(0.9); } 100% { transform: rotate(90deg) scale(0.8) translateY(20%); opacity: 0.6; } }
        .king-fallen img { animation: king-fall 0.8s ease-in forwards !important; transform-origin: center bottom; }
        
        #status { text-align: center; padding: 12px; background: #1a1816; border-radius: 8px; margin: 10px 0; color: #bababa; font-size: 15px; }
        .game-btns { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-top: 10px; }
        .history { background: #1a1816; border-radius: 8px; padding: 12px; margin-top: 10px; max-height: 80px; overflow-y: auto; }
        .history-title { color: #7c7a78; font-size: 12px; margin-bottom: 8px; }
        #movesList { display: flex; flex-wrap: wrap; gap: 3px 8px; color: #bababa; font-size: 13px; font-family: monospace; }
        .mp { color: #7c7a78; }
        
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); align-items: center; justify-content: center; z-index: 2000; }
        .modal.show { display: flex; }
        .modal-box { background: #302e2b; border-radius: 12px; padding: 25px; text-align: center; max-width: 340px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .modal-title { color: #fff; font-size: 20px; margin-bottom: 15px; }
        .modal-msg { color: #bababa; margin: 10px 0 20px; font-size: 14px; }
        .promo-opts { display: flex; justify-content: center; gap: 10px; }
        .promo-opt { width: 60px; height: 60px; background: #ebecd0; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; padding: 6px; }
        .promo-opt:active { transform: scale(0.95); }
        .promo-opt img { width: 100%; height: 100%; }
        .modal-btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        
        .snd-btn { position: fixed; top: 10px; right: 10px; background: #3d3a37; border: none; color: #fff; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 100; }
        .online-badge { display: none; align-items: center; gap: 6px; background: #2d4a2d; color: #81b64c; padding: 4px 10px; border-radius: 12px; font-size: 12px; margin-bottom: 10px; }
        .online-badge.show { display: inline-flex; }
        .online-badge .dot { width: 6px; height: 6px; background: #81b64c; border-radius: 50%; }
        .copy-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: #81b64c; color: #fff; padding: 12px 24px; border-radius: 25px; font-size: 14px; font-weight: 600; opacity: 0; transition: opacity 0.3s; z-index: 3000; pointer-events: none; }
        .copy-toast.show { opacity: 1; }
        .premove-indicator { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 13px; font-weight: 600; display: none; z-index: 100; cursor: pointer; }
        .premove-indicator.show { display: block; }
        .draw-offer { background: #f39c12; color: #000; padding: 10px; border-radius: 8px; margin: 10px 0; text-align: center; display: none; }
        .draw-offer.show { display: block; }
        .draw-offer-btns { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        
        /* –ê–Ω–∞–ª–∏–∑ */
        .analysis-panel { background: #1a1816; border-radius: 12px; padding: 15px; margin-top: 15px; display: none; }
        .analysis-panel.show { display: block; }
        .analysis-bar { height: 24px; background: #333; border-radius: 4px; overflow: hidden; display: flex; margin-bottom: 15px; }
        .analysis-bar-white { background: #f0f0f0; height: 100%; transition: width 0.3s; display: flex; align-items: center; justify-content: flex-start; padding-left: 5px; font-size: 11px; color: #333; font-weight: bold; }
        .analysis-bar-black { background: #333; height: 100%; flex: 1; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; font-size: 11px; color: #fff; font-weight: bold; }
        .analysis-moves { max-height: 200px; overflow-y: auto; }
        .analysis-move { display: flex; align-items: center; padding: 6px 8px; border-radius: 4px; margin-bottom: 4px; cursor: pointer; }
        .analysis-move:hover { background: #2d2a27; }
        .analysis-move.selected { background: #3d5a3d; }
        .analysis-move-num { color: #7c7a78; width: 30px; font-size: 12px; }
        .analysis-move-san { color: #fff; flex: 1; font-family: monospace; }
        .analysis-move-eval { font-size: 11px; padding: 2px 6px; border-radius: 3px; margin-left: 8px; }
        .eval-brilliant { background: #1baca6; color: #fff; }
        .eval-great { background: #5c8bb0; color: #fff; }
        .eval-best { background: #81b64c; color: #fff; }
        .eval-good { background: #96bc4b; color: #fff; }
        .eval-inaccuracy { background: #f7c631; color: #000; }
        .eval-mistake { background: #e68a00; color: #fff; }
        .eval-blunder { background: #ca3431; color: #fff; }
        .analysis-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .analysis-stat { background: #262421; padding: 10px; border-radius: 8px; text-align: center; }
        .analysis-stat-value { font-size: 24px; font-weight: bold; color: #fff; }
        .analysis-stat-label { font-size: 11px; color: #7c7a78; margin-top: 4px; }
        .analysis-progress { text-align: center; padding: 20px; color: #bababa; }
    </style>
</head>
<body>

<button class="snd-btn" id="sndBtn">üîä</button>
<div class="premove-indicator" id="premoveIndicator">‚ö° –ü—Ä–µ–º—É–≤ (–Ω–∞–∂–º–∏ –¥–ª—è –æ—Ç–º–µ–Ω—ã)</div>

<div class="container">
    <h1>‚ôü –®–∞—Ö–º–∞—Ç—ã</h1>
    
    <div class="menu-screen" id="menuScreen">
        <div class="menu" id="mainMenu">
            <div class="menu-title">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã</div>
            
            <div class="setting">
                <div class="setting-label"><span>–£—Ä–æ–≤–µ–Ω—å –ò–ò</span><span class="setting-value" id="eloValue">1400 ELO</span></div>
                <input type="range" id="eloSlider" min="400" max="2800" value="1400" step="200">
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–ö–æ–Ω—Ç—Ä–æ–ª—å –≤—Ä–µ–º–µ–Ω–∏</span></div>
                <div class="time-select" id="timeSelect">
                    <button class="time-btn" data-time="1|0">1+0</button>
                    <button class="time-btn" data-time="3|0">3+0</button>
                    <button class="time-btn" data-time="3|2">3+2</button>
                    <button class="time-btn" data-time="5|0">5+0</button>
                    <button class="time-btn active" data-time="10|0">10+0</button>
                    <button class="time-btn" data-time="15|10">15+10</button>
                    <button class="time-btn" data-time="0|0">‚àû</button>
                    <button class="time-btn" data-time="custom">‚öôÔ∏è</button>
                </div>
                <div class="custom-time hidden" id="customTime">
                    <label>–ú–∏–Ω:</label><input type="number" id="customMins" value="10" min="1" max="180">
                    <label>+–°–µ–∫:</label><input type="number" id="customSecs" value="0" min="0" max="60">
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–í–∞—à —Ü–≤–µ—Ç</span></div>
                <div class="color-select" id="colorSelect">
                    <button class="color-btn active" data-color="white"><img src="https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wk.png"> –ë–µ–ª—ã–µ</button>
                    <button class="color-btn" data-color="random">üé≤</button>
                    <button class="color-btn" data-color="black"><img src="https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bk.png"> –ß—ë—Ä–Ω—ã–µ</button>
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–°—Ç–∏–ª—å —Ñ–∏–≥—É—Ä</span></div>
                <div class="theme-select" id="pieceSelect">
                    <button class="theme-btn active" data-pieces="neo"><img src="https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wn.png"> Neo</button>
                    <button class="theme-btn" data-pieces="classic"><img src="https://images.chesscomfiles.com/chess-themes/pieces/classic/150/wn.png"> Classic</button>
                    <button class="theme-btn" data-pieces="wood"><img src="https://images.chesscomfiles.com/chess-themes/pieces/wood/150/wn.png"> Wood</button>
                    <button class="theme-btn" data-pieces="glass"><img src="https://images.chesscomfiles.com/chess-themes/pieces/glass/150/wn.png"> Glass</button>
                    <button class="theme-btn" data-pieces="gothic"><img src="https://images.chesscomfiles.com/chess-themes/pieces/gothic/150/wn.png"> Gothic</button>
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–¶–≤–µ—Ç –¥–æ—Å–∫–∏</span></div>
                <div class="theme-select" id="boardSelect">
                    <button class="theme-btn active" data-board="green">
                        <div class="board-preview"><div style="background:#ebecd0"></div><div style="background:#739552"></div><div style="background:#739552"></div><div style="background:#ebecd0"></div></div>
                    </button>
                    <button class="theme-btn" data-board="brown">
                        <div class="board-preview"><div style="background:#f0d9b5"></div><div style="background:#b58863"></div><div style="background:#b58863"></div><div style="background:#f0d9b5"></div></div>
                    </button>
                    <button class="theme-btn" data-board="blue">
                        <div class="board-preview"><div style="background:#dee3e6"></div><div style="background:#8ca2ad"></div><div style="background:#8ca2ad"></div><div style="background:#dee3e6"></div></div>
                    </button>
                    <button class="theme-btn" data-board="purple">
                        <div class="board-preview"><div style="background:#e8dff0"></div><div style="background:#9f7aba"></div><div style="background:#9f7aba"></div><div style="background:#e8dff0"></div></div>
                    </button>
                    <button class="theme-btn" data-board="dark">
                        <div class="board-preview"><div style="background:#a9a9a9"></div><div style="background:#4a4a4a"></div><div style="background:#4a4a4a"></div><div style="background:#a9a9a9"></div></div>
                    </button>
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–ê–Ω–∏–º–∞—Ü–∏–∏</span></div>
                <div class="toggle-setting"><span>–ê–Ω–∏–º–∞—Ü–∏—è —Ö–æ–¥–æ–≤</span><div class="toggle active" id="toggleMoveAnim"></div></div>
                <div class="toggle-setting"><span>–ê–Ω–∏–º–∞—Ü–∏—è –≤–∑—è—Ç–∏—è</span><div class="toggle active" id="toggleCaptureAnim"></div></div>
                <div class="toggle-setting"><span>–ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ç–∞</span><div class="toggle active" id="toggleMateAnim"></div></div>
            </div>
            
            <div class="menu-btns">
                <button class="btn green" id="btnPlayAI">ü§ñ –ò–≥—Ä–∞—Ç—å —Å –ò–ò</button>
            </div>
            
            <div class="online-section">
                <div class="online-title">üåê –ò–≥—Ä–∞—Ç—å —Å –¥—Ä—É–≥–æ–º</div>
                <div class="menu-btns" style="margin-top:10px;">
                    <button class="btn blue" id="btnCreateGame">‚ûï –°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É</button>
                </div>
                <div class="game-link" style="margin-top:12px;">
                    <input type="text" id="joinCode" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∏–≥—Ä—ã...">
                    <button class="btn orange" id="btnJoinGame">‚Üí</button>
                </div>
                <div class="connection-status" id="connectionStatus"></div>
            </div>
        </div>
        
        <div class="menu hidden" id="waitingRoom">
            <div class="waiting">
                <div class="waiting-spinner">‚ôü</div>
                <p style="margin-top:15px;font-size:16px;">–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...</p>
                <p style="margin-top:10px;color:#81b64c;font-size:20px;font-weight:bold;" id="gameCodeDisplay"></p>
            </div>
            <div class="game-link" style="margin-top:20px;">
                <input type="text" id="shareLink" readonly style="font-size:12px;">
                <button class="btn gray" id="btnCopyLink">üìã</button>
            </div>
            <button class="btn gray" style="margin-top:12px;width:100%;" id="btnCancelWait">‚úï –û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
    
    <div class="game-screen" id="gameScreen">
        <div id="onlineBadge" class="online-badge"><span class="dot"></span><span>–û–Ω–ª–∞–π–Ω</span></div>
        
        <div class="player-box" id="topPlayer">
            <div class="avatar" id="topAvatar">ü§ñ</div>
            <div class="player-info">
                <div class="player-name" id="topName">–ë–æ—Ç</div>
                <div class="player-rating" id="topRating">1400 ELO</div>
            </div>
            <div class="captured" id="topCaptured"></div>
            <div class="timer inactive" id="topTimer">10:00</div>
        </div>
        
        <div id="board"></div>
        
        <div class="player-box active" id="bottomPlayer">
            <div class="avatar" id="bottomAvatar">üë§</div>
            <div class="player-info">
                <div class="player-name" id="bottomName">–í—ã</div>
                <div class="player-rating" id="bottomRating">–ë–µ–ª—ã–µ</div>
            </div>
            <div class="captured" id="bottomCaptured"></div>
            <div class="timer" id="bottomTimer">10:00</div>
        </div>
        
        <div class="draw-offer" id="drawOffer">
            <span>ü§ù –°–æ–ø–µ—Ä–Ω–∏–∫ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –Ω–∏—á—å—é</span>
            <div class="draw-offer-btns">
                <button class="btn green small" id="btnAcceptDraw">‚úì –ü—Ä–∏–Ω—è—Ç—å</button>
                <button class="btn red small" id="btnDeclineDraw">‚úï –û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
            </div>
        </div>
        
        <div id="status">–í–∞—à —Ö–æ–¥</div>
        
        <div class="game-btns">
            <button class="btn gray small" id="btnBackMenu">üè†</button>
            <button class="btn gray small" id="btnUndo">‚Ü©Ô∏è</button>
            <button class="btn yellow small" id="btnDraw">ü§ù</button>
            <button class="btn red small" id="btnResign">üè≥Ô∏è</button>
            <button class="btn purple small" id="btnAnalysis">üìä</button>
        </div>
        
        <div class="history">
            <div class="history-title">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</div>
            <div id="movesList"></div>
        </div>
        
        <div class="analysis-panel" id="analysisPanel">
            <div class="menu-title">üìä –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏</div>
            <div class="analysis-bar">
                <div class="analysis-bar-white" id="analysisBarWhite" style="width:50%"></div>
                <div class="analysis-bar-black" id="analysisBarBlack"></div>
            </div>
            <div class="analysis-progress" id="analysisProgress">–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞</div>
            <div class="analysis-moves" id="analysisMoves"></div>
            <div class="analysis-stats" id="analysisStats"></div>
        </div>
    </div>
</div>

<div class="modal" id="promoModal">
    <div class="modal-box">
        <div class="modal-title">–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ</div>
        <div class="promo-opts" id="promoOpts"></div>
    </div>
</div>

<div class="modal" id="endModal">
    <div class="modal-box">
        <div class="modal-icon" id="endIcon" style="font-size:50px;margin-bottom:10px;">üèÜ</div>
        <div class="modal-title" id="endTitle">–ü–æ–±–µ–¥–∞!</div>
        <div class="modal-msg" id="endMsg"></div>
        <div class="modal-btns">
            <button class="btn green" id="btnRematch">üîÑ –†–µ–≤–∞–Ω—à</button>
            <button class="btn purple" id="btnAnalyzeEnd">üìä –ê–Ω–∞–ª–∏–∑</button>
            <button class="btn gray" id="btnEndMenu">üè† –ú–µ–Ω—é</button>
        </div>
    </div>
</div>

<div class="modal" id="confirmModal">
    <div class="modal-box">
        <div class="modal-title" id="confirmTitle">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</div>
        <div class="modal-msg" id="confirmMsg"></div>
        <div class="modal-btns">
            <button class="btn green" id="confirmYes">–î–∞</button>
            <button class="btn gray" id="confirmNo">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<div class="copy-toast" id="copyToast">‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</div>

<audio id="sndMove" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-self.mp3"></audio>
<audio id="sndCapture" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/capture.mp3"></audio>
<audio id="sndCheck" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-check.mp3"></audio>
<audio id="sndCastle" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/castle.mp3"></audio>
<audio id="sndPromo" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/promote.mp3"></audio>
<audio id="sndEnd" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/game-end.mp3"></audio>
<audio id="sndPremove" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/premove.mp3"></audio>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
// ========== –ö–û–ù–°–¢–ê–ù–¢–´ –ò –¢–ï–ú–´ ==========
const BOARD_THEMES = {
    green: { light: '#ebecd0', dark: '#739552' },
    brown: { light: '#f0d9b5', dark: '#b58863' },
    blue: { light: '#dee3e6', dark: '#8ca2ad' },
    purple: { light: '#e8dff0', dark: '#9f7aba' },
    dark: { light: '#a9a9a9', dark: '#4a4a4a' }
};

const PIECE_THEMES = ['neo', 'classic', 'wood', 'glass', 'gothic'];

function getImg(piece) {
    const theme = settings.pieceTheme || 'neo';
    const color = piece === piece.toUpperCase() ? 'w' : 'b';
    const type = piece.toLowerCase();
    return `https://images.chesscomfiles.com/chess-themes/pieces/${theme}/150/${color}${type}.png`;
}

const VAL = {p:100, n:320, b:330, r:500, q:900, k:20000};

// ========== –°–û–°–¢–û–Ø–ù–ò–ï ==========
let settings = {
    elo: 1400, color: 'white', time: '10|0',
    pieceTheme: 'neo', boardTheme: 'green',
    animMove: true, animCapture: true, animMate: true
};

let soundOn = true;
let brd, turn, sel, moves, lastMv, over, aiGo, hist, notation, capW, capB, ep, castle;
let playerColor = true, flipped = false, premove = null;
let whiteTime = 600, blackTime = 600, increment = 0, timerInterval = null;
let lowTimeWarned = {w: false, b: false};
let isOnline = false, gameCode = null, peer = null, conn = null, myColor = 'white';
let isConnecting = false;

// Drag and drop
let dragging = null, dragPiece = null, dragStartSq = null;

// Stockfish
let stockfish = null, analysisResults = [], isAnalyzing = false, fenHistory = [];

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
document.addEventListener('DOMContentLoaded', function() {
    loadSettings();
    setupEventListeners();
    checkUrlForGame();
});

function loadSettings() {
    const saved = localStorage.getItem('chessSettings');
    if (saved) {
        try { Object.assign(settings, JSON.parse(saved)); } catch(e) {}
    }
    
    document.getElementById('eloSlider').value = settings.elo;
    document.getElementById('eloValue').textContent = settings.elo + ' ELO';
    
    document.querySelectorAll('.time-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.time === settings.time);
    });
    document.querySelectorAll('[data-color]').forEach(b => {
        b.classList.toggle('active', b.dataset.color === settings.color);
    });
    document.querySelectorAll('[data-pieces]').forEach(b => {
        b.classList.toggle('active', b.dataset.pieces === settings.pieceTheme);
    });
    document.querySelectorAll('[data-board]').forEach(b => {
        b.classList.toggle('active', b.dataset.board === settings.boardTheme);
    });
    
    document.getElementById('toggleMoveAnim').classList.toggle('active', settings.animMove);
    document.getElementById('toggleCaptureAnim').classList.toggle('active', settings.animCapture);
    document.getElementById('toggleMateAnim').classList.toggle('active', settings.animMate);
}

function saveSettings() {
    localStorage.setItem('chessSettings', JSON.stringify(settings));
}

function setupEventListeners() {
    // –°–ª–∞–π–¥–µ—Ä ELO
    document.getElementById('eloSlider').addEventListener('input', function() {
        settings.elo = parseInt(this.value);
        document.getElementById('eloValue').textContent = settings.elo + ' ELO';
        saveSettings();
    });
    
    // –í—Ä–µ–º—è
    document.getElementById('timeSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.time-btn');
        if (!btn) return;
        document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        if (btn.dataset.time === 'custom') {
            document.getElementById('customTime').classList.remove('hidden');
        } else {
            document.getElementById('customTime').classList.add('hidden');
            settings.time = btn.dataset.time;
            saveSettings();
        }
    });
    
    // –¶–≤–µ—Ç
    document.getElementById('colorSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.color-btn');
        if (!btn) return;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        settings.color = btn.dataset.color;
        saveSettings();
    });
    
    // –¢–µ–º–∞ —Ñ–∏–≥—É—Ä
    document.getElementById('pieceSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.theme-btn');
        if (!btn || !btn.dataset.pieces) return;
        document.querySelectorAll('[data-pieces]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        settings.pieceTheme = btn.dataset.pieces;
        saveSettings();
    });
    
    // –¢–µ–º–∞ –¥–æ—Å–∫–∏
    document.getElementById('boardSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.theme-btn');
        if (!btn || !btn.dataset.board) return;
        document.querySelectorAll('[data-board]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        settings.boardTheme = btn.dataset.board;
        saveSettings();
    });
    
    // –ê–Ω–∏–º–∞—Ü–∏–∏
    ['toggleMoveAnim', 'toggleCaptureAnim', 'toggleMateAnim'].forEach(id => {
        document.getElementById(id).addEventListener('click', function() {
            this.classList.toggle('active');
            if (id === 'toggleMoveAnim') settings.animMove = this.classList.contains('active');
            if (id === 'toggleCaptureAnim') settings.animCapture = this.classList.contains('active');
            if (id === 'toggleMateAnim') settings.animMate = this.classList.contains('active');
            saveSettings();
        });
    });
    
    // –ö–Ω–æ–ø–∫–∏ –º–µ–Ω—é
    document.getElementById('btnPlayAI').addEventListener('click', startVsAI);
    document.getElementById('btnCreateGame').addEventListener('click', createOnlineGame);
    document.getElementById('btnJoinGame').addEventListener('click', joinOnlineGame);
    document.getElementById('btnCopyLink').addEventListener('click', copyLink);
    document.getElementById('btnCancelWait').addEventListener('click', cancelWaiting);
    document.getElementById('joinCode').addEventListener('keypress', e => { if (e.key === 'Enter') joinOnlineGame(); });
    
    // –ö–Ω–æ–ø–∫–∏ –∏–≥—Ä—ã
    document.getElementById('btnBackMenu').addEventListener('click', backToMenu);
    document.getElementById('btnUndo').addEventListener('click', undoMove);
    document.getElementById('btnDraw').addEventListener('click', offerDraw);
    document.getElementById('btnResign').addEventListener('click', resign);
    document.getElementById('btnAnalysis').addEventListener('click', startAnalysis);
    document.getElementById('btnAcceptDraw').addEventListener('click', acceptDraw);
    document.getElementById('btnDeclineDraw').addEventListener('click', declineDraw);
    
    // –ú–æ–¥–∞–ª–∫–∏
    document.getElementById('btnRematch').addEventListener('click', rematch);
    document.getElementById('btnAnalyzeEnd').addEventListener('click', function() {
        document.getElementById('endModal').classList.remove('show');
        startAnalysis();
    });
    document.getElementById('btnEndMenu').addEventListener('click', backToMenu);
    document.getElementById('confirmNo').addEventListener('click', closeConfirm);
    
    // –ó–≤—É–∫
    document.getElementById('sndBtn').addEventListener('click', toggleSound);
    
    // –ü—Ä–µ–º—É–≤
    document.getElementById('premoveIndicator').addEventListener('click', clearPremove);
    
    // Drag —Å–æ–±—ã—Ç–∏—è –Ω–∞ –¥–æ—Å–∫–µ
    document.getElementById('board').addEventListener('mousedown', onDragStart);
    document.getElementById('board').addEventListener('touchstart', onDragStart, {passive: false});
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('touchmove', onDragMove, {passive: false});
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchend', onDragEnd);
}

// ========== –ó–í–£–ö–ò ==========
function playSound(id) {
    if (!soundOn) return;
    const audio = document.getElementById(id);
    if (audio) { audio.currentTime = 0; audio.play().catch(() => {}); }
}

function toggleSound() {
    soundOn = !soundOn;
    document.getElementById('sndBtn').textContent = soundOn ? 'üîä' : 'üîá';
}

// ========== –í–†–ï–ú–Ø ==========
function getTimeSettings() {
    const activeBtn = document.querySelector('.time-btn.active');
    if (activeBtn && activeBtn.dataset.time === 'custom') {
        const mins = parseInt(document.getElementById('customMins').value) || 10;
        const secs = parseInt(document.getElementById('customSecs').value) || 0;
        return { time: mins * 60, inc: secs };
    }
    const [mins, inc] = settings.time.split('|').map(Number);
    return { time: mins * 60, inc: inc };
}

function formatTime(seconds) {
    if (seconds <= 0) return '0:00';
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
}

function startTimer() {
    const ts = getTimeSettings();
    if (ts.time === 0) return;
    stopTimer();
    timerInterval = setInterval(function() {
        if (over || aiGo) return;
        if (turn === 'w') {
            whiteTime -= 0.1;
            if (whiteTime <= 10 && !lowTimeWarned.w) { playSound('sndMove'); lowTimeWarned.w = true; }
            if (whiteTime <= 0) { whiteTime = 0; timeOut('white'); }
        } else {
            blackTime -= 0.1;
            if (blackTime <= 10 && !lowTimeWarned.b) { playSound('sndMove'); lowTimeWarned.b = true; }
            if (blackTime <= 0) { blackTime = 0; timeOut('black'); }
        }
        updateTimerDisplay();
    }, 100);
}

function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }

function addIncrement(isWhite) { if (isWhite) whiteTime += increment; else blackTime += increment; }

function updateTimerDisplay() {
    const ts = getTimeSettings();
    const topTimer = document.getElementById('topTimer');
    const bottomTimer = document.getElementById('bottomTimer');
    
    if (ts.time === 0) { topTimer.classList.add('hidden'); bottomTimer.classList.add('hidden'); return; }
    
    topTimer.classList.remove('hidden'); bottomTimer.classList.remove('hidden');
    const topIsBlack = playerColor;
    topTimer.textContent = formatTime(topIsBlack ? blackTime : whiteTime);
    bottomTimer.textContent = formatTime(topIsBlack ? whiteTime : blackTime);
    
    const isWhiteTurn = turn === 'w';
    const topActive = topIsBlack ? !isWhiteTurn : isWhiteTurn;
    topTimer.classList.toggle('inactive', !topActive || over);
    bottomTimer.classList.toggle('inactive', topActive || over);
    topTimer.classList.toggle('low', (topIsBlack ? blackTime : whiteTime) <= 30 && topActive && !over);
    bottomTimer.classList.toggle('low', (topIsBlack ? whiteTime : blackTime) <= 30 && !topActive && !over);
}

function timeOut(color) {
    over = true; stopTimer();
    const playerLost = (color === 'white') === playerColor;
    showEnd(playerLost ? 'lose' : 'win', '–í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ');
}

// ========== –û–ù–õ–ê–ô–ù ==========
function genCode() { return Math.random().toString(36).substr(2, 5).toUpperCase(); }

function createOnlineGame() {
    gameCode = genCode();
    myColor = settings.color === 'random' ? (Math.random() < 0.5 ? 'white' : 'black') : settings.color;
    
    document.getElementById('gameCodeDisplay').textContent = gameCode;
    document.getElementById('shareLink').value = window.location.href.split('?')[0] + '?g=' + gameCode;
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('waitingRoom').classList.remove('hidden');
    
    setupPeer(true);
}

function joinOnlineGame() {
    if (isConnecting) return;
    const code = document.getElementById('joinCode').value.trim().toUpperCase();
    if (!code) { showStatus('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∏–≥—Ä—ã', 'error'); return; }
    
    gameCode = code;
    myColor = 'pending';
    isConnecting = true;
    showStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...', 'waiting');
    
    setupPeer(false);
}

function setupPeer(isHost) {
    if (peer) { peer.destroy(); peer = null; }
    
    const peerId = isHost ? 'chess-' + gameCode : 'chess-guest-' + Math.random().toString(36).substr(2, 8);
    
    peer = new Peer(peerId, {
        config: {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        }
    });
    
    peer.on('open', function(id) {
        console.log('Peer –æ—Ç–∫—Ä—ã—Ç:', id);
        if (isHost) {
            // –•–æ—Å—Ç –∂–¥—ë—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        } else {
            // –ì–æ—Å—Ç—å –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ —Ö–æ—Å—Ç—É
            connectToHost();
        }
    });
    
    peer.on('connection', function(connection) {
        console.log('–í—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ');
        conn = connection;
        setupConnection(true);
    });
    
    peer.on('error', function(err) {
        console.error('Peer error:', err);
        if (err.type === 'peer-unavailable') {
            showStatus('–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error');
        } else if (err.type === 'network' || err.type === 'server-error') {
            showStatus('–û—à–∏–±–∫–∞ —Å–µ—Ç–∏', 'error');
        }
        isConnecting = false;
    });
}

function connectToHost() {
    const hostId = 'chess-' + gameCode;
    console.log('–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫:', hostId);
    
    conn = peer.connect(hostId, { reliable: true });
    
    const timeout = setTimeout(function() {
        if (isConnecting) {
            showStatus('–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —Ö–æ—Å—Ç –æ—Ñ—Ñ–ª–∞–π–Ω', 'error');
            isConnecting = false;
            if (conn) conn.close();
        }
    }, 12000);
    
    conn.on('open', function() {
        console.log('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ');
        clearTimeout(timeout);
        setupConnection(false);
    });
    
    conn.on('error', function(err) {
        console.error('Connection error:', err);
        clearTimeout(timeout);
        showStatus('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è', 'error');
        isConnecting = false;
    });
}

function setupConnection(isHost) {
    conn.on('data', function(data) {
        console.log('–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ:', data);
        handleOnlineMessage(data, isHost);
    });
    
    conn.on('close', function() {
        console.log('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ');
        if (isOnline && !over) {
            document.getElementById('status').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è';
        }
    });
    
    if (isHost) {
        // –•–æ—Å—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–æ—Å—Ç—é
        myColor = settings.color === 'random' ? (Math.random() < 0.5 ? 'white' : 'black') : settings.color;
        conn.send({ type: 'init', hostColor: myColor, time: settings.time });
    }
}

function handleOnlineMessage(data, isHost) {
    if (data.type === 'init' && !isHost) {
        // –ì–æ—Å—Ç—å –ø–æ–ª—É—á–∏–ª –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç —Ö–æ—Å—Ç–∞
        myColor = data.hostColor === 'white' ? 'black' : 'white';
        settings.time = data.time;
        conn.send({ type: 'ready' });
        startOnline();
    }
    
    if (data.type === 'ready' && isHost) {
        // –•–æ—Å—Ç –ø–æ–ª—É—á–∏–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç –≥–æ—Å—Ç—è
        startOnline();
    }
    
    if (data.type === 'move' && data.mv) {
        doMove(data.mv, data.promo || 'q');
        playMoveSound(data.mv);
        addIncrement(turn === 'b');
        aiGo = false;
        updUI(); draw(); checkEnd();
        if (premove && !over) setTimeout(executePremove, 100);
    }
    
    if (data.type === 'resign') { over = true; stopTimer(); showEnd('win', '–°–æ–ø–µ—Ä–Ω–∏–∫ —Å–¥–∞–ª—Å—è'); }
    if (data.type === 'draw-offer') { document.getElementById('drawOffer').classList.add('show'); playSound('sndMove'); }
    if (data.type === 'draw-accept') { over = true; stopTimer(); showEnd('draw', '–ù–∏—á—å—è'); document.getElementById('drawOffer').classList.remove('show'); }
    if (data.type === 'draw-decline') { document.getElementById('status').textContent = '–ù–∏—á—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞'; document.getElementById('drawOffer').classList.remove('show'); setTimeout(function() { if (!over) updUI(); }, 2000); }
}

function startOnline() {
    isOnline = true;
    isConnecting = false;
    playerColor = myColor === 'white';
    flipped = !playerColor;
    
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('mainMenu').classList.add('hidden');
    initGame();
    
    document.getElementById('topName').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫';
    document.getElementById('topAvatar').textContent = 'üë§';
    document.getElementById('topRating').textContent = myColor === 'white' ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
    document.getElementById('bottomRating').textContent = myColor === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.add('show');
    
    showGame();
    startTimer();
    showStatus('–°–æ–µ–¥–∏–Ω–µ–Ω–æ!', 'success');
}

function showStatus(msg, type) {
    const el = document.getElementById('connectionStatus');
    el.textContent = msg;
    el.className = 'connection-status ' + (type || '');
}

function cancelWaiting() {
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
    if (peer) { peer.destroy(); peer = null; }
    if (conn) { conn.close(); conn = null; }
    gameCode = null;
    isConnecting = false;
}

function copyLink() {
    const link = document.getElementById('shareLink').value;
    navigator.clipboard.writeText(link).catch(() => {
        document.getElementById('shareLink').select();
        document.execCommand('copy');
    });
    document.getElementById('copyToast').classList.add('show');
    setTimeout(() => document.getElementById('copyToast').classList.remove('show'), 2000);
}

function checkUrlForGame() {
    const params = new URLSearchParams(window.location.search);
    const g = params.get('g');
    if (g) {
        document.getElementById('joinCode').value = g;
        setTimeout(joinOnlineGame, 500);
    }
}

// ========== –ò–ì–†–ê ==========
function initGame() {
    brd = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    turn = 'w'; sel = null; moves = []; lastMv = null; over = false; aiGo = false;
    hist = []; notation = []; capW = []; capB = []; ep = null;
    castle = { K: 1, Q: 1, k: 1, q: 1 };
    fenHistory = [getFEN()];
    clearPremove();
    lowTimeWarned = {w: false, b: false};
    
    const ts = getTimeSettings();
    whiteTime = ts.time; blackTime = ts.time; increment = ts.inc;
    
    document.getElementById('drawOffer').classList.remove('show');
    document.getElementById('endModal').classList.remove('show');
    document.getElementById('promoModal').classList.remove('show');
    document.getElementById('analysisPanel').classList.remove('show');
    analysisResults = [];
    updateTimerDisplay();
}

function startVsAI() {
    isOnline = false;
    playerColor = settings.color === 'random' ? Math.random() < 0.5 : settings.color === 'white';
    flipped = !playerColor;
    
    initGame();
    
    document.getElementById('topName').textContent = '–ë–æ—Ç';
    document.getElementById('topAvatar').textContent = 'ü§ñ';
    document.getElementById('topRating').textContent = settings.elo + ' ELO';
    document.getElementById('bottomRating').textContent = playerColor ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.remove('show');
    
    showGame();
    startTimer();
    
    if (!playerColor) { aiGo = true; updUI(); setTimeout(aiMove, 400); }
}

function showGame() {
    document.getElementById('menuScreen').classList.add('hidden');
    document.getElementById('gameScreen').classList.add('active');
    updUI(); draw();
}

function backToMenu() {
    stopTimer();
    document.getElementById('menuScreen').classList.remove('hidden');
    document.getElementById('gameScreen').classList.remove('active');
    document.getElementById('endModal').classList.remove('show');
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('waitingRoom').classList.add('hidden');
    if (peer) { peer.destroy(); peer = null; }
    if (conn) { conn.close(); conn = null; }
    isOnline = false;
    clearPremove();
}

function rematch() {
    document.getElementById('endModal').classList.remove('show');
    if (isOnline) { initGame(); updUI(); draw(); startTimer(); }
    else startVsAI();
}

// ========== DRAG AND DROP ==========
function onDragStart(e) {
    if (over) return;
    
    const touch = e.touches ? e.touches[0] : e;
    const sq = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!sq || !sq.classList.contains('sq')) return;
    
    const r = parseInt(sq.dataset.r);
    const c = parseInt(sq.dataset.c);
    const piece = brd[r][c];
    
    if (!piece) return;
    
    const isMyTurn = (turn === 'w') === playerColor;
    const isMyPiece = isW(piece) === playerColor;
    
    // –ú–æ–∂–Ω–æ —Ç—è–Ω—É—Ç—å —Å–≤–æ–∏ —Ñ–∏–≥—É—Ä—ã (–¥–ª—è –ø—Ä–µ–º—É–≤–∞ –∏–ª–∏ –æ–±—ã—á–Ω–æ–≥–æ —Ö–æ–¥–∞)
    if (!isMyPiece) return;
    
    e.preventDefault();
    
    dragging = { r, c };
    dragStartSq = sq;
    sel = { r, c };
    moves = isMyTurn ? getMoves(r, c) : getMoves(r, c, false);
    
    // –°–æ–∑–¥–∞—ë–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—É—é —Ñ–∏–≥—É—Ä—É
    const boardRect = document.getElementById('board').getBoundingClientRect();
    const sqSize = boardRect.width / 8;
    
    dragPiece = document.createElement('div');
    dragPiece.className = 'dragging-piece';
    dragPiece.style.width = sqSize + 'px';
    dragPiece.style.height = sqSize + 'px';
    dragPiece.innerHTML = `<img src="${getImg(piece)}">`;
    dragPiece.style.left = touch.clientX + 'px';
    dragPiece.style.top = touch.clientY + 'px';
    document.body.appendChild(dragPiece);
    
    sq.classList.add('dragging-from');
    draw();
}

function onDragMove(e) {
    if (!dragging || !dragPiece) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    dragPiece.style.left = touch.clientX + 'px';
    dragPiece.style.top = touch.clientY + 'px';
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∫–ª–µ—Ç–∫–∏ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
    document.querySelectorAll('.sq.drag-over').forEach(s => s.classList.remove('drag-over'));
    const sq = document.elementFromPoint(touch.clientX, touch.clientY);
    if (sq && sq.classList.contains('sq')) {
        const tr = parseInt(sq.dataset.r);
        const tc = parseInt(sq.dataset.c);
        const isValidMove = moves.some(m => m.tr === tr && m.tc === tc);
        if (isValidMove) sq.classList.add('drag-over');
    }
}

function onDragEnd(e) {
    if (!dragging) return;
    
    document.querySelectorAll('.sq.dragging-from').forEach(s => s.classList.remove('dragging-from'));
    document.querySelectorAll('.sq.drag-over').forEach(s => s.classList.remove('drag-over'));
    
    if (dragPiece) {
        dragPiece.remove();
        dragPiece = null;
    }
    
    const touch = e.changedTouches ? e.changedTouches[0] : e;
    const sq = document.elementFromPoint(touch.clientX, touch.clientY);
    
    if (sq && sq.classList.contains('sq')) {
        const tr = parseInt(sq.dataset.r);
        const tc = parseInt(sq.dataset.c);
        
        const isMyTurn = (turn === 'w') === playerColor;
        
        if (isMyTurn) {
            // –û–±—ã—á–Ω—ã–π —Ö–æ–¥
            const mv = moves.find(m => m.tr === tr && m.tc === tc);
            if (mv) {
                if (mv.pro) showPromo(mv);
                else execMove(mv);
            }
        } else {
            // –ü—Ä–µ–º—É–≤
            if (dragging.r !== tr || dragging.c !== tc) {
                setPremove(dragging.r, dragging.c, tr, tc);
            }
        }
    }
    
    dragging = null;
    sel = null;
    moves = [];
    draw();
}

// ========== –ü–†–ï–ú–£–í ==========
function clearPremove() {
    premove = null;
    document.getElementById('premoveIndicator').classList.remove('show');
    draw();
}

function setPremove(fromR, fromC, toR, toC) {
    premove = { from: { r: fromR, c: fromC }, to: { r: toR, c: toC } };
    playSound('sndPremove');
    document.getElementById('premoveIndicator').classList.add('show');
    sel = null; moves = [];
    draw();
}

function executePremove() {
    if (!premove) return;
    const pm = premove;
    clearPremove();
    
    const piece = brd[pm.from.r][pm.from.c];
    if (!piece || isW(piece) !== playerColor) { draw(); return; }
    
    const legalMoves = getMoves(pm.from.r, pm.from.c);
    const validMove = legalMoves.find(m => m.tr === pm.to.r && m.tc === pm.to.c);
    
    if (validMove) execMove(validMove, validMove.pro ? 'q' : undefined);
    else draw();
}

// ========== –õ–û–ì–ò–ö–ê ==========
function isW(p) { return p && p === p.toUpperCase(); }
function isB(p) { return p && p === p.toLowerCase(); }

function getMoves(r, c, legal) {
    if (legal === undefined) legal = true;
    const p = brd[r][c]; if (!p) return [];
    const w = isW(p), t = p.toLowerCase(); let m = [];
    
    if (t === 'p') {
        const d = w ? -1 : 1, start = w ? 6 : 1, promo = w ? 0 : 7;
        if (brd[r+d] && !brd[r+d][c]) {
            m.push({ fr:r, fc:c, tr:r+d, tc:c, pro: r+d===promo });
            if (r === start && !brd[r+2*d][c]) m.push({ fr:r, fc:c, tr:r+2*d, tc:c, dbl:1 });
        }
        [-1, 1].forEach(function(dc) {
            const nc = c + dc; if (nc < 0 || nc > 7) return;
            if (brd[r+d] && brd[r+d][nc] && (w ? isB(brd[r+d][nc]) : isW(brd[r+d][nc])))
                m.push({ fr:r, fc:c, tr:r+d, tc:nc, pro: r+d===promo });
            if (ep && ep.r === r+d && ep.c === nc) m.push({ fr:r, fc:c, tr:r+d, tc:nc, isEp:1 });
        });
    }
    
    if (t === 'n') {
        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(function(o) {
            const nr = r+o[0], nc = c+o[1];
            if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!brd[nr][nc] || (w ? isB(brd[nr][nc]) : isW(brd[nr][nc]))))
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
        });
    }
    
    if (t === 'b' || t === 'q') {
        [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(function(o) {
            let nr = r+o[0], nc = c+o[1];
            while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                if (brd[nr][nc] && (w ? isW(brd[nr][nc]) : isB(brd[nr][nc]))) break;
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
                if (brd[nr][nc]) break; nr += o[0]; nc += o[1];
            }
        });
    }
    
    if (t === 'r' || t === 'q') {
        [[-1,0],[1,0],[0,-1],[0,1]].forEach(function(o) {
            let nr = r+o[0], nc = c+o[1];
            while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                if (brd[nr][nc] && (w ? isW(brd[nr][nc]) : isB(brd[nr][nc]))) break;
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
                if (brd[nr][nc]) break; nr += o[0]; nc += o[1];
            }
        });
    }
    
    if (t === 'k') {
        for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++) {
            if (!dr && !dc) continue;
            const nr = r+dr, nc = c+dc;
            if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!brd[nr][nc] || (w ? isB(brd[nr][nc]) : isW(brd[nr][nc]))))
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
        }
        if (legal && !inCheck(w)) {
            const row = w ? 7 : 0;
            if (castle[w ? 'K' : 'k'] && !brd[row][5] && !brd[row][6] && brd[row][7] && brd[row][7].toLowerCase()==='r')
                if (!attacked(row,5,!w) && !attacked(row,6,!w)) m.push({ fr:row, fc:4, tr:row, tc:6, cst:'k' });
            if (castle[w ? 'Q' : 'q'] && !brd[row][1] && !brd[row][2] && !brd[row][3] && brd[row][0] && brd[row][0].toLowerCase()==='r')
                if (!attacked(row,2,!w) && !attacked(row,3,!w)) m.push({ fr:row, fc:4, tr:row, tc:2, cst:'q' });
        }
    }
    
    if (legal) m = m.filter(function(mv) { return isLegal(mv, w); });
    return m;
}

function isLegal(mv, w) {
    const pc = brd[mv.fr][mv.fc], cap = brd[mv.tr][mv.tc];
    brd[mv.tr][mv.tc] = pc; brd[mv.fr][mv.fc] = '';
    let epCap = null;
    if (mv.isEp) { const er = w ? mv.tr+1 : mv.tr-1; epCap = brd[er][mv.tc]; brd[er][mv.tc] = ''; }
    const ok = !inCheck(w);
    brd[mv.fr][mv.fc] = pc; brd[mv.tr][mv.tc] = cap;
    if (epCap !== null) brd[w ? mv.tr+1 : mv.tr-1][mv.tc] = epCap;
    return ok;
}

function findKing(w) {
    const k = w ? 'K' : 'k';
    for (let r=0; r<8; r++) for (let c=0; c<8; c++) if (brd[r][c]===k) return {r:r,c:c};
    return null;
}

function attacked(r, c, byW) {
    for (let i=0; i<8; i++) for (let j=0; j<8; j++) {
        const p = brd[i][j];
        if (p && isW(p)===byW) {
            const mvs = getMoves(i, j, false);
            for (let k=0; k<mvs.length; k++) if (mvs[k].tr===r && mvs[k].tc===c) return true;
        }
    }
    return false;
}

function inCheck(w) { const k = findKing(w); return k && attacked(k.r, k.c, !w); }

function allMoves(w) {
    let a = [];
    for (let r=0; r<8; r++) for (let c=0; c<8; c++)
        if (brd[r][c] && isW(brd[r][c])===w) a = a.concat(getMoves(r,c));
    return a;
}

function doMove(mv, promo) {
    if (!promo) promo = 'q';
    const pc = brd[mv.fr][mv.fc], w = isW(pc), cap = brd[mv.tr][mv.tc];
    hist.push({ mv:{fr:mv.fr,fc:mv.fc,tr:mv.tr,tc:mv.tc,cst:mv.cst,pro:mv.pro,isEp:mv.isEp,dbl:mv.dbl}, pc:pc, cap:cap, ep:ep?{r:ep.r,c:ep.c}:null, castle:{K:castle.K,Q:castle.Q,k:castle.k,q:castle.q}, epCap:null, capW:capW.slice(), capB:capB.slice() });
    
    let captured = cap;
    if (mv.isEp) { const er = w ? mv.tr+1 : mv.tr-1; captured = brd[er][mv.tc]; hist[hist.length-1].epCap = captured; brd[er][mv.tc] = ''; }
    if (captured) (w ? capW : capB).push(captured);
    
    brd[mv.tr][mv.tc] = pc; brd[mv.fr][mv.fc] = '';
    
    if (mv.cst) {
        const row = mv.tr;
        if (mv.cst === 'k') { brd[row][5] = brd[row][7]; brd[row][7] = ''; }
        else { brd[row][3] = brd[row][0]; brd[row][0] = ''; }
    }
    if (mv.pro) brd[mv.tr][mv.tc] = w ? promo.toUpperCase() : promo.toLowerCase();
    
    if (pc === 'K') { castle.K = 0; castle.Q = 0; }
    if (pc === 'k') { castle.k = 0; castle.q = 0; }
    if (mv.fr===7 && mv.fc===7) castle.K = 0;
    if (mv.fr===7 && mv.fc===0) castle.Q = 0;
    if (mv.fr===0 && mv.fc===7) castle.k = 0;
    if (mv.fr===0 && mv.fc===0) castle.q = 0;
    if (mv.tr===7 && mv.tc===7) castle.K = 0;
    if (mv.tr===7 && mv.tc===0) castle.Q = 0;
    if (mv.tr===0 && mv.tc===7) castle.k = 0;
    if (mv.tr===0 && mv.tc===0) castle.q = 0;
    
    ep = mv.dbl ? { r: (mv.fr+mv.tr)/2, c: mv.fc } : null;
    
    const files = 'abcdefgh', ranks = '87654321';
    let n = mv.cst === 'k' ? 'O-O' : mv.cst === 'q' ? 'O-O-O' : '';
    if (!n) {
        if (pc.toUpperCase() !== 'P') n += pc.toUpperCase();
        if (captured) { if (pc.toUpperCase() === 'P') n += files[mv.fc]; n += 'x'; }
        n += files[mv.tc] + ranks[mv.tr];
        if (mv.pro) n += '=' + promo.toUpperCase();
    }
    notation.push(n);
    
    lastMv = mv; turn = turn === 'w' ? 'b' : 'w';
    fenHistory.push(getFEN());
    
    return { captured: !!captured, cst: mv.cst, pro: mv.pro };
}

function getFEN() {
    let fen = '';
    for (let r = 0; r < 8; r++) {
        let empty = 0;
        for (let c = 0; c < 8; c++) {
            if (brd[r][c]) {
                if (empty > 0) { fen += empty; empty = 0; }
                fen += brd[r][c];
            } else empty++;
        }
        if (empty > 0) fen += empty;
        if (r < 7) fen += '/';
    }
    fen += ' ' + turn;
    let c = '';
    if (castle.K) c += 'K'; if (castle.Q) c += 'Q';
    if (castle.k) c += 'k'; if (castle.q) c += 'q';
    fen += ' ' + (c || '-');
    fen += ' ' + (ep ? 'abcdefgh'[ep.c] + (8-ep.r) : '-');
    fen += ' 0 1';
    return fen;
}

function undoMove() {
    if (isOnline || hist.length < 2 || over || aiGo) return;
    clearPremove();
    for (let i = 0; i < 2 && hist.length; i++) {
        const h = hist.pop(); notation.pop(); fenHistory.pop();
        brd[h.mv.fr][h.mv.fc] = h.pc; brd[h.mv.tr][h.mv.tc] = h.cap;
        if (h.epCap) brd[isW(h.pc) ? h.mv.tr+1 : h.mv.tr-1][h.mv.tc] = h.epCap;
        if (h.mv.cst) {
            const row = h.mv.tr;
            if (h.mv.cst === 'k') { brd[row][7] = brd[row][5]; brd[row][5] = ''; }
            else { brd[row][0] = brd[row][3]; brd[row][3] = ''; }
        }
        capW = h.capW; capB = h.capB; ep = h.ep; castle = h.castle; turn = turn === 'w' ? 'b' : 'w';
    }
    lastMv = hist.length ? hist[hist.length-1].mv : null;
    sel = null; moves = []; updUI(); draw();
}

// ========== UI ==========
function draw() {
    const board = document.getElementById('board');
    board.innerHTML = '';
    const kPos = findKing(turn === 'w'), check = inCheck(turn === 'w');
    const theme = BOARD_THEMES[settings.boardTheme] || BOARD_THEMES.green;
    
    for (let i = 0; i < 64; i++) {
        let r = Math.floor(i / 8), c = i % 8;
        if (flipped) { r = 7 - r; c = 7 - c; }
        
        const sq = document.createElement('div');
        sq.className = 'sq';
        sq.style.background = (r + c) % 2 ? theme.dark : theme.light;
        sq.dataset.r = r;
        sq.dataset.c = c;
        
        if (sel && sel.r === r && sel.c === c) sq.classList.add('sel');
        if (lastMv && ((lastMv.fr === r && lastMv.fc === c) || (lastMv.tr === r && lastMv.tc === c))) sq.classList.add('lm');
        if (check && kPos && kPos.r === r && kPos.c === c) sq.classList.add('ch');
        
        if (premove) {
            if (premove.from.r === r && premove.from.c === c) sq.classList.add('premove-from');
            if (premove.to.r === r && premove.to.c === c) sq.classList.add('premove-to');
        }
        
        for (let j = 0; j < moves.length; j++) {
            if (moves[j].tr === r && moves[j].tc === c) {
                sq.classList.add(brd[r][c] ? 'cap' : 'dot');
                break;
            }
        }
        
        if (brd[r][c]) {
            const img = document.createElement('img');
            img.src = getImg(brd[r][c]);
            img.draggable = false;
            sq.appendChild(img);
        }
        
        sq.addEventListener('click', function() { onClick(parseInt(this.dataset.r), parseInt(this.dataset.c)); });
        board.appendChild(sq);
    }
    updCaptured(); updMoves(); updateTimerDisplay();
}

function onClick(r, c) {
    if (dragging) return; // –ï—Å–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫
    
    const isMyTurn = (turn === 'w') === playerColor;
    const pc = brd[r][c];
    
    if (premove) { clearPremove(); return; }
    
    if (!isMyTurn && !over) {
        if (sel) {
            if (sel.r === r && sel.c === c) { sel = null; moves = []; draw(); return; }
            setPremove(sel.r, sel.c, r, c);
            return;
        }
        if (pc && isW(pc) === playerColor) {
            sel = { r: r, c: c };
            moves = getMoves(r, c, false);
            draw();
        }
        return;
    }
    
    if (over) return;
    
    if (sel) {
        let mv = null;
        for (let i = 0; i < moves.length; i++) {
            if (moves[i].tr === r && moves[i].tc === c) { mv = moves[i]; break; }
        }
        if (mv) {
            if (mv.pro) { showPromo(mv); return; }
            execMove(mv);
            return;
        }
    }
    
    if (pc && isW(pc) === (turn === 'w')) {
        sel = { r: r, c: c }; moves = getMoves(r, c);
    } else {
        sel = null; moves = [];
    }
    draw();
}

function execMove(mv, promo) {
    if (!promo) promo = 'q';
    const wasWhite = turn === 'w';
    const hadCapture = !!brd[mv.tr][mv.tc] || mv.isEp;
    
    // –ê–Ω–∏–º–∞—Ü–∏—è –≤–∑—è—Ç–∏—è
    if (hadCapture && settings.animCapture) {
        showCaptureEffect(mv.tr, mv.tc);
    }
    
    const res = doMove(mv, promo);
    sel = null; moves = [];
    playMoveSound(mv, res);
    addIncrement(wasWhite);
    
    if (isOnline && conn) conn.send({ type: 'move', mv: { fr:mv.fr, fc:mv.fc, tr:mv.tr, tc:mv.tc, cst:mv.cst, pro:mv.pro, isEp:mv.isEp, dbl:mv.dbl }, promo: promo });
    
    updUI(); draw();
    if (checkEnd()) return;
    
    if (!isOnline) {
        aiGo = true; updUI();
        setTimeout(aiMove, 200);
    }
}

function showCaptureEffect(r, c) {
    const board = document.getElementById('board');
    const sqSize = board.offsetWidth / 8;
    const displayR = flipped ? 7 - r : r;
    const displayC = flipped ? 7 - c : c;
    
    const effect = document.createElement('div');
    effect.className = 'capture-effect';
    effect.style.left = (displayC * sqSize) + 'px';
    effect.style.top = (displayR * sqSize) + 'px';
    effect.style.width = sqSize + 'px';
    effect.style.height = sqSize + 'px';
    
    // –ö–æ–ª—å—Ü–æ
    const ring = document.createElement('div');
    ring.className = 'capture-ring';
    effect.appendChild(ring);
    
    board.appendChild(effect);
    setTimeout(() => effect.remove(), 500);
}

function playMoveSound(mv, res) {
    if ((res && res.pro) || mv.pro) playSound('sndPromo');
    else if ((res && res.cst) || mv.cst) playSound('sndCastle');
    else if ((res && res.captured) || (brd[mv.tr] && brd[mv.tr][mv.tc])) playSound('sndCapture');
    else playSound('sndMove');
    setTimeout(function() { if (inCheck(turn === 'w')) playSound('sndCheck'); }, 50);
}

function showPromo(mv) {
    const modal = document.getElementById('promoModal');
    const opts = document.getElementById('promoOpts');
    opts.innerHTML = '';
    const isWhite = turn === 'w';
    const pcs = isWhite ? ['Q','R','B','N'] : ['q','r','b','n'];
    pcs.forEach(function(p) {
        const div = document.createElement('div');
        div.className = 'promo-opt';
        const img = document.createElement('img');
        img.src = getImg(p);
        div.appendChild(img);
        div.addEventListener('click', function() {
            modal.classList.remove('show');
            execMove(mv, p.toLowerCase());
        });
        opts.appendChild(div);
    });
    modal.classList.add('show');
}

function checkEnd() {
    const isWhiteTurn = turn === 'w';
    if (allMoves(isWhiteTurn).length === 0) {
        over = true; stopTimer();
        const check = inCheck(isWhiteTurn);
        const win = check && isWhiteTurn !== playerColor;
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è –∫–æ—Ä–æ–ª—è –ø—Ä–∏ –º–∞—Ç–µ
        if (check && settings.animMate) {
            const kingPos = findKing(isWhiteTurn);
            if (kingPos) {
                setTimeout(() => {
                    const displayR = flipped ? 7 - kingPos.r : kingPos.r;
                    const displayC = flipped ? 7 - kingPos.c : kingPos.c;
                    const idx = displayR * 8 + displayC;
                    const sq = document.getElementById('board').children[idx];
                    if (sq) sq.classList.add('king-fallen');
                }, 100);
            }
        }
        
        setTimeout(() => showEnd(check ? (win ? 'win' : 'lose') : 'draw', check ? '–ú–∞—Ç' : '–ü–∞—Ç'), 800);
        return true;
    }
    return false;
}

function showEnd(res, msg) {
    playSound('sndEnd');
    const icons = { win: 'üèÜ', lose: 'üò¢', draw: 'ü§ù' };
    const titles = { win: '–ü–æ–±–µ–¥–∞!', lose: '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ', draw: '–ù–∏—á—å—è' };
    document.getElementById('endIcon').textContent = icons[res];
    document.getElementById('endTitle').textContent = titles[res];
    document.getElementById('endMsg').textContent = msg;
    document.getElementById('endModal').classList.add('show');
}

function updUI() {
    const isMyTurn = (turn === 'w') === playerColor;
    document.getElementById('bottomPlayer').classList.toggle('active', isMyTurn && !over);
    document.getElementById('topPlayer').classList.toggle('active', !isMyTurn && !over);
    
    let status = '–í–∞—à —Ö–æ–¥';
    if (over) status = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
    else if (isOnline) status = isMyTurn ? '–í–∞—à —Ö–æ–¥' : '–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...';
    else if (aiGo) status = '–ò–ò –¥—É–º–∞–µ—Ç...';
    document.getElementById('status').textContent = status;
}

function updCaptured() {
    const ord = p => ({q:0,r:1,b:2,n:3,p:4})[p.toLowerCase()] || 5;
    const render = a => a.slice().sort((x,y) => ord(x)-ord(y)).map(p => `<img src="${getImg(p)}">`).join('');
    document.getElementById(flipped ? 'topCaptured' : 'bottomCaptured').innerHTML = render(capB);
    document.getElementById(flipped ? 'bottomCaptured' : 'topCaptured').innerHTML = render(capW);
}

function updMoves() {
    let h = '';
    for (let i = 0; i < notation.length; i += 2) {
        h += `<span><span class="mp">${i/2+1}.</span>${notation[i]}${notation[i+1] ? ' '+notation[i+1] : ''} </span>`;
    }
    document.getElementById('movesList').innerHTML = h;
}

// ========== –°–î–ê–¢–¨–°–Ø / –ù–ò–ß–¨–Ø ==========
function resign() {
    if (over) return;
    showConfirm('–°–¥–∞—Ç—å—Å—è?', '–í—ã —É–≤–µ—Ä–µ–Ω—ã?', function() {
        over = true; stopTimer();
        if (isOnline && conn) conn.send({ type: 'resign' });
        showEnd('lose', '–í—ã —Å–¥–∞–ª–∏—Å—å');
    });
}

function offerDraw() {
    if (over) return;
    if (isOnline && conn) {
        conn.send({ type: 'draw-offer' });
        document.getElementById('status').textContent = '–ù–∏—á—å—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞...';
    } else {
        const ev = evaluate();
        const aiAdvantage = playerColor ? ev < -100 : ev > 100;
        if (aiAdvantage) {
            document.getElementById('status').textContent = '–ò–ò –æ—Ç–∫–ª–æ–Ω–∏–ª –Ω–∏—á—å—é';
            setTimeout(function() { if (!over) updUI(); }, 2000);
        } else {
            over = true; stopTimer();
            showEnd('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
        }
    }
}

function acceptDraw() {
    document.getElementById('drawOffer').classList.remove('show');
    over = true; stopTimer();
    if (isOnline && conn) conn.send({ type: 'draw-accept' });
    showEnd('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
}

function declineDraw() {
    document.getElementById('drawOffer').classList.remove('show');
    if (isOnline && conn) conn.send({ type: 'draw-decline' });
    document.getElementById('status').textContent = '–ù–∏—á—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞';
    setTimeout(function() { if (!over) updUI(); }, 2000);
}

function showConfirm(title, msg, onYes) {
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMsg').textContent = msg;
    document.getElementById('confirmYes').onclick = function() { closeConfirm(); onYes(); };
    document.getElementById('confirmModal').classList.add('show');
}

function closeConfirm() { document.getElementById('confirmModal').classList.remove('show'); }

// ========== –ê–ù–ê–õ–ò–ó (Stockfish) ==========
function startAnalysis() {
    if (notation.length === 0) {
        alert('–ù–µ—Ç —Ö–æ–¥–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞');
        return;
    }
    
    if (isAnalyzing) return;
    
    document.getElementById('analysisPanel').classList.add('show');
    document.getElementById('analysisProgress').textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ Stockfish...';
    document.getElementById('analysisMoves').innerHTML = '';
    document.getElementById('analysisStats').innerHTML = '';
    
    isAnalyzing = true;
    analysisResults = [];
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º Stockfish
    if (!stockfish) {
        stockfish = new Worker('https://cdn.jsdelivr.net/npm/stockfish.js@10.0.2/stockfish.js');
        stockfish.onmessage = handleStockfishMessage;
    }
    
    stockfish.postMessage('uci');
    stockfish.postMessage('isready');
}

let currentAnalysisIndex = 0;
let analysisEvals = [];
let bestMoves = [];

function handleStockfishMessage(e) {
    const line = e.data;
    
    if (line === 'readyok') {
        currentAnalysisIndex = 0;
        analysisEvals = [];
        bestMoves = [];
        analyzeNextPosition();
    }
    
    if (line.startsWith('info depth') && line.includes(' cp ')) {
        const cpMatch = line.match(/cp (-?\d+)/);
        const pvMatch = line.match(/pv ([a-h][1-8][a-h][1-8])/);
        if (cpMatch) {
            const cp = parseInt(cpMatch[1]);
            const isWhiteMove = currentAnalysisIndex % 2 === 1;
            analysisEvals[currentAnalysisIndex] = isWhiteMove ? cp : -cp;
        }
        if (pvMatch) {
            bestMoves[currentAnalysisIndex] = pvMatch[1];
        }
    }
    
    if (line.startsWith('info depth') && line.includes(' mate ')) {
        const mateMatch = line.match(/mate (-?\d+)/);
        if (mateMatch) {
            const mate = parseInt(mateMatch[1]);
            const isWhiteMove = currentAnalysisIndex % 2 === 1;
            analysisEvals[currentAnalysisIndex] = (isWhiteMove ? 1 : -1) * (mate > 0 ? 10000 : -10000);
        }
    }
    
    if (line.startsWith('bestmove')) {
        currentAnalysisIndex++;
        if (currentAnalysisIndex < fenHistory.length) {
            document.getElementById('analysisProgress').textContent = `–ê–Ω–∞–ª–∏–∑: ${currentAnalysisIndex} / ${fenHistory.length - 1}`;
            analyzeNextPosition();
        } else {
            finishAnalysis();
        }
    }
}

function analyzeNextPosition() {
    if (currentAnalysisIndex >= fenHistory.length) {
        finishAnalysis();
        return;
    }
    
    const fen = fenHistory[currentAnalysisIndex];
    stockfish.postMessage('position fen ' + fen);
    stockfish.postMessage('go depth 12');
}

function finishAnalysis() {
    isAnalyzing = false;
    document.getElementById('analysisProgress').textContent = '';
    
    // –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ö–æ–¥—ã
    const classifications = [];
    let whiteAccuracy = 0, blackAccuracy = 0;
    let whiteMoves = 0, blackMoves = 0;
    const stats = { brilliant: 0, great: 0, best: 0, good: 0, inaccuracy: 0, mistake: 0, blunder: 0 };
    
    for (let i = 1; i < fenHistory.length; i++) {
        const evalBefore = analysisEvals[i - 1] || 0;
        const evalAfter = analysisEvals[i] || 0;
        const isWhiteMove = i % 2 === 1;
        
        // –ü–æ—Ç–µ—Ä—è –æ—Ç —Ö–æ–¥–∞ (—Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞)
        const loss = isWhiteMove ? (evalBefore - evalAfter) : (evalAfter - evalBefore);
        
        let classification;
        if (loss < -30) {
            // –•–æ–¥ —É–ª—É—á—à–∏–ª –ø–æ–∑–∏—Ü–∏—é –±–æ–ª—å—à–µ –æ–∂–∏–¥–∞–µ–º–æ–≥–æ - –±—Ä–∏–ª–ª–∏–∞–Ω—Ç–æ–≤—ã–π
            classification = 'brilliant';
        } else if (loss < -10) {
            classification = 'great';
        } else if (loss <= 0) {
            classification = 'best';
        } else if (loss <= 25) {
            classification = 'good';
        } else if (loss <= 50) {
            classification = 'inaccuracy';
        } else if (loss <= 150) {
            classification = 'mistake';
        } else {
            classification = 'blunder';
        }
        
        stats[classification]++;
        classifications.push({
            moveNum: Math.ceil(i / 2),
            san: notation[i - 1],
            eval: evalAfter,
            classification,
            isWhite: isWhiteMove
        });
        
        // –¢–æ—á–Ω–æ—Å—Ç—å
        const accuracy = Math.max(0, 100 - Math.abs(loss) * 0.5);
        if (isWhiteMove) {
            whiteAccuracy += accuracy;
            whiteMoves++;
        } else {
            blackAccuracy += accuracy;
            blackMoves++;
        }
    }
    
    // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ö–æ–¥—ã
    const movesHtml = classifications.map((c, idx) => {
        const evalText = Math.abs(c.eval) >= 10000 ? (c.eval > 0 ? 'M+' : 'M-') : (c.eval / 100).toFixed(1);
        const symbols = { brilliant: '!!', great: '!', best: '‚úì', good: '', inaccuracy: '?!', mistake: '?', blunder: '??' };
        return `
            <div class="analysis-move" data-idx="${idx}">
                <span class="analysis-move-num">${c.moveNum}${c.isWhite ? '.' : '...'}</span>
                <span class="analysis-move-san">${c.san}</span>
                <span class="analysis-move-eval eval-${c.classification}">${symbols[c.classification] || ''} ${evalText}</span>
            </div>
        `;
    }).join('');
    
    document.getElementById('analysisMoves').innerHTML = movesHtml;
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    const wAcc = whiteMoves > 0 ? Math.round(whiteAccuracy / whiteMoves) : 0;
    const bAcc = blackMoves > 0 ? Math.round(blackAccuracy / blackMoves) : 0;
    
    document.getElementById('analysisStats').innerHTML = `
        <div class="analysis-stat">
            <div class="analysis-stat-value">${wAcc}%</div>
            <div class="analysis-stat-label">–¢–æ—á–Ω–æ—Å—Ç—å –±–µ–ª—ã—Ö</div>
        </div>
        <div class="analysis-stat">
            <div class="analysis-stat-value">${bAcc}%</div>
            <div class="analysis-stat-label">–¢–æ—á–Ω–æ—Å—Ç—å —á—ë—Ä–Ω—ã—Ö</div>
        </div>
    `;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞—Ä –æ—Ü–µ–Ω–∫–∏
    updateAnalysisBar(analysisEvals[fenHistory.length - 1] || 0);
    
    // –ö–ª–∏–∫–∏ –Ω–∞ —Ö–æ–¥—ã
    document.querySelectorAll('.analysis-move').forEach(el => {
        el.addEventListener('click', function() {
            const idx = parseInt(this.dataset.idx);
            document.querySelectorAll('.analysis-move').forEach(e => e.classList.remove('selected'));
            this.classList.add('selected');
            updateAnalysisBar(classifications[idx].eval);
        });
    });
}

function updateAnalysisBar(cp) {
    const percent = 50 + Math.max(-50, Math.min(50, cp / 10));
    const whiteBar = document.getElementById('analysisBarWhite');
    const blackBar = document.getElementById('analysisBarBlack');
    whiteBar.style.width = percent + '%';
    
    const evalText = Math.abs(cp) >= 10000 ? (cp > 0 ? 'M+' : 'M-') : (cp >= 0 ? '+' : '') + (cp / 100).toFixed(1);
    if (cp >= 0) {
        whiteBar.textContent = evalText;
        blackBar.textContent = '';
    } else {
        whiteBar.textContent = '';
        blackBar.textContent = evalText;
    }
}

// ========== –ò–ò ==========
function aiMove() {
    if (over) return;
    const best = findBest();
    if (best) {
        const hadCapture = !!brd[best.tr][best.tc] || best.isEp;
        if (hadCapture && settings.animCapture) showCaptureEffect(best.tr, best.tc);
        
        doMove(best, 'q');
        playMoveSound(best, { captured: hadCapture, cst: best.cst });
        addIncrement(turn === 'b');
    }
    aiGo = false; updUI(); draw();
    if (!checkEnd() && premove) setTimeout(executePremove, 100);
}

function findBest() {
    const isAiW = !playerColor;
    let mvs = allMoves(isAiW);
    if (!mvs.length) return null;
    
    const depth = settings.elo < 800 ? 1 : settings.elo < 1500 ? 2 : settings.elo < 2200 ? 3 : 4;
    const rand = Math.max(5, 70 - settings.elo / 40);
    
    mvs = mvs.map(mv => {
        let sc = 0;
        const tg = brd[mv.tr][mv.tc];
        if (tg) sc += VAL[tg.toLowerCase()] * 10;
        if (mv.pro) sc += 800;
        if (mv.cst) sc += 60;
        sc += (3.5 - Math.abs(mv.tc - 3.5)) * 8 + (3.5 - Math.abs(mv.tr - 3.5)) * 5;
        if (notation.length < 6) sc += Math.random() * 50;
        return { mv, sc };
    }).sort((a, b) => b.sc - a.sc).map(x => x.mv);
    
    let best = mvs[0], bestSc = -Infinity;
    for (let i = 0; i < mvs.length; i++) {
        const mv = mvs[i];
        const st = save();
        doMove(mv, 'q');
        const sc = -minimax(depth - 1, -Infinity, Infinity, !isAiW) + (Math.random() - 0.5) * rand;
        restore(st);
        if (sc > bestSc) { bestSc = sc; best = mv; }
    }
    return best;
}

function minimax(d, a, b, isMax) {
    if (d === 0) return evaluate();
    const mvs = allMoves(isMax);
    if (!mvs.length) return inCheck(isMax) ? (isMax ? -15000 : 15000) : 0;
    
    if (isMax) {
        let max = -Infinity;
        for (let mv of mvs) {
            const st = save(); doMove(mv, 'q');
            const sc = minimax(d - 1, a, b, false);
            restore(st);
            if (sc > max) max = sc;
            if (sc > a) a = sc;
            if (b <= a) break;
        }
        return max;
    } else {
        let min = Infinity;
        for (let mv of mvs) {
            const st = save(); doMove(mv, 'q');
            const sc = minimax(d - 1, a, b, true);
            restore(st);
            if (sc < min) min = sc;
            if (sc < b) b = sc;
            if (b <= a) break;
        }
        return min;
    }
}

const PST = {
    p: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
    n: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
    b: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,10,10,10,10,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,5,10,10,5,0,-10],[-10,0,5,5,5,5,0,-10],[-10,0,0,0,0,0,0,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
    r: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
    q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
    k: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
};

function evaluate() {
    let sc = 0;
    for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = brd[r][c]; if (!p) continue;
        const w = isW(p), t = p.toLowerCase();
        let v = VAL[t] || 0;
        if (PST[t]) v += PST[t][w ? r : 7-r][c];
        sc += w ? v : -v;
    }
    return sc;
}

function save() {
    return {
        brd: brd.map(r => r.slice()),
        turn, ep: ep ? {r:ep.r, c:ep.c} : null,
        castle: {...castle},
        capW: capW.slice(), capB: capB.slice(),
        notation: notation.slice(),
        histLen: hist.length,
        fenHistory: fenHistory.slice()
    };
}

function restore(s) {
    brd = s.brd.map(r => r.slice());
    turn = s.turn;
    ep = s.ep ? {r:s.ep.r, c:s.ep.c} : null;
    castle = {...s.castle};
    capW = s.capW.slice(); capB = s.capB.slice();
    notation = s.notation.slice();
    fenHistory = s.fenHistory.slice();
    while (hist.length > s.histLen) hist.pop();
}
</script>
</body>
</html>
