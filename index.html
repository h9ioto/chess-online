<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∞—Ö–º–∞—Ç—ã</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ñ–æ–Ω –º–µ–Ω—é */
        .menu-bg {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            z-index: -2;
        }
        
        .menu-bg::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 200, 120, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(100, 150, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 200, 100, 0.1) 0%, transparent 50%);
            animation: bgPulse 8s ease-in-out infinite;
        }
        
        @keyframes bgPulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        /* –ü–ª–∞–≤–∞—é—â–∏–µ —à–∞—Ö–º–∞—Ç–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã –Ω–∞ —Ñ–æ–Ω–µ */
        .floating-pieces {
            position: fixed;
            inset: 0;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }
        
        .floating-piece {
            position: absolute;
            font-size: 40px;
            opacity: 0.1;
            animation: floatPiece 20s linear infinite;
        }
        
        @keyframes floatPiece {
            0% { transform: translateY(100vh) rotate(0deg); }
            100% { transform: translateY(-100px) rotate(360deg); }
        }
        
        .game-bg {
            position: fixed;
            inset: 0;
            background: #262421;
            z-index: -1;
        }
        
        .container { 
            max-width: 500px; 
            margin: 0 auto; 
            padding: 10px;
            padding-bottom: 80px;
        }
        
        h1 { 
            color: #fff; 
            text-align: center; 
            font-size: 28px; 
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        
        /* –ú–µ–Ω—é */
        .menu {
            background: rgba(26, 24, 22, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .menu.hidden { display: none; }
        
        .menu-title {
            color: #81b64c;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .setting { margin-bottom: 20px; }
        
        .setting-label {
            color: #bababa;
            font-size: 13px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
        }
        
        .setting-value { color: #81b64c; font-weight: 600; }
        
        /* –°–ª–∞–π–¥–µ—Ä */
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #3d3a37;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(145deg, #8bc34a, #689f38);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        /* –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ */
        .select-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 8px;
        }
        
        .select-btn {
            padding: 12px 8px;
            border: 2px solid #3d3a37;
            border-radius: 10px;
            background: rgba(38, 36, 33, 0.8);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .select-btn:hover { border-color: #555; }
        .select-btn.active { 
            border-color: #81b64c; 
            background: rgba(129, 182, 76, 0.2);
            box-shadow: 0 0 15px rgba(129, 182, 76, 0.3);
        }
        
        .select-btn img { width: 32px; height: 32px; }
        
        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
        }
        
        .color-preview div { width: 15px; height: 15px; }
        
        /* –ö–Ω–æ–ø–∫–∏ */
        .btn {
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
            width: 100%;
        }
        
        .btn:active { transform: scale(0.97); }
        .btn.green { background: linear-gradient(145deg, #8bc34a, #689f38); color: #fff; }
        .btn.blue { background: linear-gradient(145deg, #5c9ce6, #4a90d9); color: #fff; }
        .btn.orange { background: linear-gradient(145deg, #ff9800, #f57c00); color: #fff; }
        .btn.gray { background: #3d3a37; color: #bababa; }
        .btn.red { background: linear-gradient(145deg, #e57373, #c62828); color: #fff; }
        .btn.small { padding: 10px 14px; font-size: 13px; }
        
        .menu-btns { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        
        /* –û–Ω–ª–∞–π–Ω —Å–µ–∫—Ü–∏—è */
        .online-section {
            background: rgba(74, 144, 226, 0.1);
            border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .online-title { color: #5c9ce6; font-size: 14px; margin-bottom: 12px; text-align: center; }
        
        .game-link { display: flex; gap: 8px; margin-top: 10px; }
        
        .game-link input {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #2d2a27;
            color: #fff;
            font-size: 14px;
            text-align: center;
            letter-spacing: 2px;
        }
        
        .join-status { color: #f39c12; font-size: 12px; text-align: center; margin-top: 8px; }
        
        /* –ö–æ–º–Ω–∞—Ç–∞ –æ–∂–∏–¥–∞–Ω–∏—è */
        .waiting {
            text-align: center;
            padding: 30px;
            color: #bababa;
        }
        
        .waiting-spinner {
            font-size: 60px;
            animation: spin 3s linear infinite;
        }
        
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .game-code {
            font-size: 32px;
            font-weight: bold;
            color: #81b64c;
            letter-spacing: 5px;
            margin: 15px 0;
            font-family: monospace;
        }
        
        /* –≠–∫—Ä–∞–Ω—ã */
        .screen { display: none; }
        .screen.active { display: block; }
        
        /* –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        .player-box {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: #1a1816;
            border-radius: 10px;
            margin: 8px 0;
            transition: all 0.3s;
        }
        
        .player-box.active {
            background: #2d2a27;
            box-shadow: inset 0 0 0 2px #81b64c;
        }
        
        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: #4a4745;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            margin-right: 12px;
        }
        
        .player-info { flex: 1; }
        .player-name { color: #fff; font-size: 14px; font-weight: 600; }
        .player-rating { color: #7c7a78; font-size: 12px; }
        
        .timer {
            background: #2d2a27;
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            font-family: monospace;
            min-width: 70px;
            text-align: center;
        }
        
        .timer.low { background: #c0392b; animation: pulse 0.5s infinite; }
        .timer.inactive { background: #1a1816; color: #555; }
        .timer.hidden { display: none; }
        
        @keyframes pulse { 50% { opacity: 0.7; } }
        
        .captured { display: flex; flex-wrap: wrap; gap: 2px; margin-left: 10px; }
        .captured img { width: 18px; height: 18px; filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.5)); }
        
        /* –î–æ—Å–∫–∞ */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            max-width: 480px;
            margin: 0 auto;
            touch-action: none;
        }
        
        .sq {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background 0.15s;
        }
        
        /* –¶–≤–µ—Ç–∞ –¥–æ—Å–∫–∏ */
        .board-green .sq.light { background: #eeeed2; }
        .board-green .sq.dark { background: #769656; }
        .board-brown .sq.light { background: #f0d9b5; }
        .board-brown .sq.dark { background: #b58863; }
        .board-blue .sq.light { background: #dee3e6; }
        .board-blue .sq.dark { background: #8ca2ad; }
        .board-purple .sq.light { background: #e8d5e1; }
        .board-purple .sq.dark { background: #9b72a8; }
        .board-dark .sq.light { background: #4a4a4a; }
        .board-dark .sq.dark { background: #2d2d2d; }
        
        .sq.selected { background: #f7f769 !important; }
        .sq.last-move { background: #f7f783 !important; }
        .sq.check { background: #e84a4a !important; }
        .sq.premove { background: #e74c3c !important; }
        
        .sq.can-move::after {
            content: '';
            width: 32%;
            height: 32%;
            background: rgba(0,0,0,0.12);
            border-radius: 50%;
            position: absolute;
        }
        
        .sq.can-capture::after {
            content: '';
            width: 100%;
            height: 100%;
            border: 5px solid rgba(0,0,0,0.12);
            border-radius: 50%;
            position: absolute;
            box-sizing: border-box;
        }
        
        .sq.drag-over { background: rgba(255, 255, 0, 0.4) !important; }
        
        .sq img.piece {
            width: 85%;
            height: 85%;
            pointer-events: none;
            filter: drop-shadow(2px 3px 3px rgba(0,0,0,0.3));
            transition: transform 0.1s;
        }
        
        .sq.dragging img.piece { opacity: 0.4; }
        
        /* –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è –∫–æ—Ä–æ–ª—è */
        .sq img.piece.fallen {
            animation: fallKing 0.8s ease-in forwards;
        }
        
        @keyframes fallKing {
            0% { transform: rotate(0deg) scale(1); }
            30% { transform: rotate(-15deg) scale(1.1); }
            100% { transform: rotate(-90deg) translateX(-20%) scale(0.9); opacity: 0.7; }
        }
        
        /* –ü—Ä–∏–∑—Ä–∞–∫ –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏ */
        #dragGhost {
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            width: 70px;
            height: 70px;
            filter: drop-shadow(3px 5px 5px rgba(0,0,0,0.4));
            display: none;
        }
        
        #dragGhost.visible { display: block; }
        
        /* –°—Ç–∞—Ç—É—Å */
        #status {
            text-align: center;
            padding: 12px;
            background: #1a1816;
            border-radius: 10px;
            margin: 10px 0;
            color: #bababa;
            font-size: 15px;
        }
        
        /* –ö–Ω–æ–ø–∫–∏ –∏–≥—Ä—ã */
        .game-btns {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        /* –ò—Å—Ç–æ—Ä–∏—è */
        .history {
            background: #1a1816;
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .history-title { color: #7c7a78; font-size: 12px; margin-bottom: 8px; }
        
        #movesList {
            display: flex;
            flex-wrap: wrap;
            gap: 4px 10px;
            color: #bababa;
            font-size: 13px;
            font-family: monospace;
        }
        
        .move-num { color: #555; }
        
        /* –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–º–∞–ª–µ–Ω—å–∫–æ–µ, –∑–∞–∫—Ä—ã–≤–∞–µ–º–æ–µ) */
        .result-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-150px);
            background: #2d2a27;
            border: 2px solid #81b64c;
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
            z-index: 5000;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            visibility: hidden;
            opacity: 0;
        }
        
        .result-toast.show { 
            transform: translateX(-50%) translateY(0); 
            visibility: visible;
            opacity: 1;
        }
        
        .result-toast .icon { font-size: 36px; margin-bottom: 8px; }
        .result-toast .title { color: #fff; font-size: 18px; font-weight: bold; }
        .result-toast .msg { color: #bababa; font-size: 13px; margin: 5px 0 12px; }
        .result-toast .close-btn {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: #666;
            font-size: 18px;
            cursor: pointer;
        }
        
        .result-btns { display: flex; gap: 10px; justify-content: center; }
        
        /* –ó–∞–ø—Ä–æ—Å (–Ω–∏—á—å—è, –æ—Ç–º–µ–Ω–∞ —Ö–æ–¥–∞) */
        .request-bar {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: #000;
            padding: 12px 15px;
            border-radius: 10px;
            margin: 10px 0;
            display: none;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        
        .request-bar.show { display: flex; }
        .request-bar span { font-weight: 600; font-size: 13px; }
        .request-bar .btns { display: flex; gap: 8px; }
        .request-bar button {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
        }
        .request-bar .accept { background: #27ae60; color: #fff; }
        .request-bar .decline { background: #c0392b; color: #fff; }
        
        /* –ù–∞—Å—Ç—Ä–æ–π–∫–∏ */
        .settings-panel {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100%;
            background: #1a1816;
            z-index: 6000;
            padding: 20px;
            overflow-y: auto;
            transition: right 0.3s;
            box-shadow: -5px 0 30px rgba(0,0,0,0.5);
        }
        
        .settings-panel.open { right: 0; }
        
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 5999;
            display: none;
        }
        
        .settings-overlay.show { display: block; }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .settings-header h2 { color: #fff; font-size: 18px; }
        .settings-header button {
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }
        
        .setting-group { margin-bottom: 20px; }
        .setting-group h3 { color: #81b64c; font-size: 13px; margin-bottom: 10px; }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #333;
        }
        
        .toggle-row span { color: #bababa; font-size: 14px; }
        
        .toggle {
            width: 50px;
            height: 26px;
            background: #3d3a37;
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle.on { background: #81b64c; }
        
        .toggle::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }
        
        .toggle.on::after { left: 26px; }
        
        /* –ú–æ–¥–∞–ª–∫–∏ */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            align-items: center;
            justify-content: center;
            z-index: 7000;
        }
        
        .modal.show { display: flex; }
        
        .modal-box {
            background: #302e2b;
            border-radius: 16px;
            padding: 25px;
            text-align: center;
            max-width: 320px;
            width: 90%;
        }
        
        .modal-title { color: #fff; font-size: 18px; margin-bottom: 15px; }
        
        .promo-opts {
            display: flex;
            justify-content: center;
            gap: 12px;
        }
        
        .promo-opt {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .promo-opt:hover { transform: scale(1.1); box-shadow: 0 5px 20px rgba(0,0,0,0.3); }
        .promo-opt img { width: 90%; height: 90%; }
        
        /* –ó–≤—É–∫ */
        .sound-btn {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(61, 58, 55, 0.9);
            border: none;
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }
        
        .settings-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(61, 58, 55, 0.9);
            border: none;
            color: #fff;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
        }
        
        /* –û–Ω–ª–∞–π–Ω –±–µ–π–¥–∂ */
        .online-badge {
            display: none;
            align-items: center;
            gap: 6px;
            background: rgba(129, 182, 76, 0.2);
            color: #81b64c;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 12px;
            margin-bottom: 10px;
            width: fit-content;
        }
        
        .online-badge.show { display: inline-flex; }
        .online-badge .dot { width: 8px; height: 8px; background: #81b64c; border-radius: 50%; animation: blink 1.5s infinite; }
        
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* –ü—Ä–µ–º—É–≤ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä */
        .premove-bar {
            background: #c0392b;
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            display: none;
            font-size: 13px;
        }
        
        .premove-bar.show { display: block; }
        
        /* –¢–æ—Å—Ç */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #81b64c;
            color: #fff;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            z-index: 8000;
            transition: transform 0.3s;
        }
        
        .toast.show { transform: translateX(-50%) translateY(0); }
        
        /* –ê–Ω–∞–ª–∏–∑ */
        .analysis-screen {
            background: #262421;
            min-height: 100vh;
            padding: 10px;
        }
        
        .analysis-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .analysis-header h2 { color: #fff; font-size: 18px; flex: 1; }
        
        .eval-bar-container {
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .eval-bar {
            height: 100%;
            background: #fff;
            width: 50%;
            transition: width 0.3s;
        }
        
        .accuracy-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .accuracy-box {
            flex: 1;
            background: #1a1816;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }
        
        .accuracy-box .label { color: #888; font-size: 12px; }
        .accuracy-box .value { color: #fff; font-size: 24px; font-weight: bold; margin: 5px 0; }
        .accuracy-box.white { border: 2px solid #f0f0f0; }
        .accuracy-box.black { border: 2px solid #555; }
        
        .analysis-moves {
            background: #1a1816;
            border-radius: 10px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .analysis-move {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            cursor: pointer;
        }
        
        .analysis-move:hover { background: #2d2a27; }
        .analysis-move .num { color: #666; width: 30px; font-size: 12px; }
        .analysis-move .san { color: #fff; flex: 1; font-family: monospace; }
        .analysis-move .eval { color: #888; font-size: 12px; margin-right: 10px; }
        .analysis-move .class { font-size: 14px; font-weight: bold; min-width: 25px; text-align: center; }
        
        .class-brilliant { color: #1baca6; }
        .class-great { color: #5c9ce6; }
        .class-best { color: #81b64c; }
        .class-good { color: #81b64c; }
        .class-inaccuracy { color: #f7c631; }
        .class-mistake { color: #e69422; }
        .class-blunder { color: #ca3431; }
        
        .analysis-progress {
            text-align: center;
            color: #bababa;
            padding: 40px;
        }
        
        .analysis-progress .spinner {
            font-size: 40px;
            animation: spin 2s linear infinite;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

<div class="menu-bg"></div>
<div class="floating-pieces" id="floatingPieces"></div>
<div class="game-bg" id="gameBg" style="display:none;"></div>

<button class="sound-btn" id="soundBtn">üîä</button>
<button class="settings-btn" id="settingsBtn">‚öôÔ∏è</button>

<img id="dragGhost" src="" alt="">

<div class="container">
    <!-- –ú–µ–Ω—é -->
    <div class="screen active" id="menuScreen">
        <h1>‚ôü –®–∞—Ö–º–∞—Ç—ã</h1>
        
        <div class="menu" id="mainMenu">
            <div class="menu-title">üéÆ –ù–æ–≤–∞—è –∏–≥—Ä–∞</div>
            
            <div class="setting">
                <div class="setting-label">
                    <span>–£—Ä–æ–≤–µ–Ω—å –ò–ò</span>
                    <span class="setting-value" id="eloValue">1400</span>
                </div>
                <input type="range" id="eloSlider" min="400" max="2800" value="1400" step="100">
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–í—Ä–µ–º—è</span></div>
                <div class="select-grid" id="timeSelect">
                    <button class="select-btn" data-time="1|0">1+0</button>
                    <button class="select-btn" data-time="3|0">3+0</button>
                    <button class="select-btn" data-time="5|0">5+0</button>
                    <button class="select-btn active" data-time="10|0">10+0</button>
                    <button class="select-btn" data-time="15|10">15+10</button>
                    <button class="select-btn" data-time="0|0">‚àû</button>
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–¶–≤–µ—Ç</span></div>
                <div class="select-grid" id="colorSelect">
                    <button class="select-btn active" data-color="white">‚¨ú –ë–µ–ª—ã–µ</button>
                    <button class="select-btn" data-color="random">üé≤ –°–ª—É—á–∞–π–Ω–æ</button>
                    <button class="select-btn" data-color="black">‚¨õ –ß—ë—Ä–Ω—ã–µ</button>
                </div>
            </div>
            
            <div class="menu-btns">
                <button class="btn green" id="btnPlayAI">ü§ñ –ò–≥—Ä–∞—Ç—å —Å –ò–ò</button>
            </div>
            
            <div class="online-section">
                <div class="online-title">üåê –ò–≥—Ä–∞—Ç—å —Å –¥—Ä—É–≥–æ–º</div>
                <button class="btn blue" id="btnCreate" style="margin-top:10px;">‚ú® –°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É</button>
                <div class="game-link">
                    <input type="text" id="joinCode" placeholder="–ö–æ–¥ –∏–≥—Ä—ã" maxlength="5" style="text-transform:uppercase;">
                    <button class="btn orange" id="btnJoin" style="width:auto;padding:12px 20px;">‚Üí</button>
                </div>
                <div class="join-status" id="joinStatus"></div>
            </div>
        </div>
        
        <div class="menu hidden" id="waitingRoom">
            <div class="waiting">
                <div class="waiting-spinner">‚ôü</div>
                <p style="margin-top:15px;">–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...</p>
                <div class="game-code" id="gameCodeDisplay"></div>
                <p style="font-size:12px;color:#666;">–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –¥—Ä—É–≥—É</p>
            </div>
            <button class="btn gray" style="margin-top:20px;" id="btnCancelWait">‚úï –û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
    
    <!-- –ò–≥—Ä–∞ -->
    <div class="screen" id="gameScreen">
        <div class="online-badge" id="onlineBadge"><span class="dot"></span> –û–Ω–ª–∞–π–Ω</div>
        
        <div class="player-box" id="topPlayer">
            <div class="avatar" id="topAvatar">ü§ñ</div>
            <div class="player-info">
                <div class="player-name" id="topName">–ë–æ—Ç</div>
                <div class="player-rating" id="topRating">1400</div>
            </div>
            <div class="captured" id="topCaptured"></div>
            <div class="timer inactive" id="topTimer">10:00</div>
        </div>
        
        <div id="board" class="board-green"></div>
        
        <div class="player-box active" id="bottomPlayer">
            <div class="avatar" id="bottomAvatar">üë§</div>
            <div class="player-info">
                <div class="player-name" id="bottomName">–í—ã</div>
                <div class="player-rating" id="bottomRating">–ë–µ–ª—ã–µ</div>
            </div>
            <div class="captured" id="bottomCaptured"></div>
            <div class="timer" id="bottomTimer">10:00</div>
        </div>
        
        <div class="request-bar" id="drawRequest">
            <span>ü§ù –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –Ω–∏—á—å–µ–π</span>
            <div class="btns">
                <button class="accept" id="acceptDraw">‚úì</button>
                <button class="decline" id="declineDraw">‚úï</button>
            </div>
        </div>
        
        <div class="request-bar" id="undoRequest">
            <span>‚Ü©Ô∏è –ó–∞–ø—Ä–æ—Å –æ—Ç–º–µ–Ω—ã —Ö–æ–¥–∞</span>
            <div class="btns">
                <button class="accept" id="acceptUndo">‚úì</button>
                <button class="decline" id="declineUndo">‚úï</button>
            </div>
        </div>
        
        <div class="premove-bar" id="premoveBar">‚ö° –ü—Ä–µ–º—É–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–Ω–∞–∂–º–∏—Ç–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã)</div>
        
        <div id="status">–í–∞—à —Ö–æ–¥</div>
        
        <div class="game-btns">
            <button class="btn gray small" id="btnMenu">üè†</button>
            <button class="btn gray small" id="btnUndo">‚Ü©Ô∏è</button>
            <button class="btn gray small" id="btnDraw">ü§ù</button>
            <button class="btn red small" id="btnResign">üè≥Ô∏è</button>
        </div>
        
        <div class="history">
            <div class="history-title">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</div>
            <div id="movesList"></div>
        </div>
    </div>
    
    <!-- –ê–Ω–∞–ª–∏–∑ -->
    <div class="screen" id="analysisScreen">
        <div class="analysis-header">
            <button class="btn gray small" id="btnBackFromAnalysis">‚Üê</button>
            <h2>üìä –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏</h2>
        </div>
        
        <div class="eval-bar-container">
            <div class="eval-bar" id="evalBar"></div>
        </div>
        
        <div class="accuracy-row">
            <div class="accuracy-box white">
                <div class="label">–ë–µ–ª—ã–µ</div>
                <div class="value" id="whiteAccuracy">-</div>
            </div>
            <div class="accuracy-box black">
                <div class="label">–ß—ë—Ä–Ω—ã–µ</div>
                <div class="value" id="blackAccuracy">-</div>
            </div>
        </div>
        
        <div id="board2" class="board-green" style="max-width:300px;margin:0 auto 15px;"></div>
        
        <div class="analysis-progress" id="analysisProgress">
            <div class="spinner">‚ôü</div>
            <div>–ê–Ω–∞–ª–∏–∑: <span id="analysisCount">0</span> / <span id="analysisTotal">0</span></div>
        </div>
        
        <div class="analysis-moves" id="analysisMoves" style="display:none;"></div>
    </div>
</div>

<!-- –†–µ–∑—É–ª—å—Ç–∞—Ç (–º–∞–ª–µ–Ω—å–∫–∏–π —Ç–æ—Å—Ç) -->
<div class="result-toast" id="resultToast">
    <button class="close-btn" id="closeResult">√ó</button>
    <div class="icon" id="resultIcon">üèÜ</div>
    <div class="title" id="resultTitle">–ü–æ–±–µ–¥–∞!</div>
    <div class="msg" id="resultMsg">–ú–∞—Ç</div>
    <div class="result-btns">
        <button class="btn green small" id="btnRematch">üîÑ –ï—â—ë</button>
        <button class="btn blue small" id="btnAnalysis">üìä</button>
        <button class="btn gray small" id="btnToMenu">üè†</button>
    </div>
</div>

<!-- –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏ -->
<div class="modal" id="promoModal">
    <div class="modal-box">
        <div class="modal-title">–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏</div>
        <div class="promo-opts" id="promoOpts"></div>
    </div>
</div>

<!-- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ -->
<div class="settings-overlay" id="settingsOverlay"></div>
<div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
        <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
        <button id="closeSettings">√ó</button>
    </div>
    
    <div class="setting-group">
        <h3>–°—Ç–∏–ª—å —Ñ–∏–≥—É—Ä</h3>
        <div class="select-grid" id="pieceStyleSelect">
            <button class="select-btn active" data-style="neo">Neo</button>
            <button class="select-btn" data-style="classic">Classic</button>
            <button class="select-btn" data-style="wood">Wood</button>
            <button class="select-btn" data-style="glass">Glass</button>
        </div>
    </div>
    
    <div class="setting-group">
        <h3>–¶–≤–µ—Ç –¥–æ—Å–∫–∏</h3>
        <div class="select-grid" id="boardColorSelect">
            <button class="select-btn active" data-board="green">
                <div class="color-preview"><div style="background:#eeeed2"></div><div style="background:#769656"></div><div style="background:#769656"></div><div style="background:#eeeed2"></div></div>
                –ó–µ–ª—ë–Ω–∞—è
            </button>
            <button class="select-btn" data-board="brown">
                <div class="color-preview"><div style="background:#f0d9b5"></div><div style="background:#b58863"></div><div style="background:#b58863"></div><div style="background:#f0d9b5"></div></div>
                –ö–æ—Ä–∏—á–Ω–µ–≤–∞—è
            </button>
            <button class="select-btn" data-board="blue">
                <div class="color-preview"><div style="background:#dee3e6"></div><div style="background:#8ca2ad"></div><div style="background:#8ca2ad"></div><div style="background:#dee3e6"></div></div>
                –°–∏–Ω—è—è
            </button>
            <button class="select-btn" data-board="purple">
                <div class="color-preview"><div style="background:#e8d5e1"></div><div style="background:#9b72a8"></div><div style="background:#9b72a8"></div><div style="background:#e8d5e1"></div></div>
                –§–∏–æ–ª–µ—Ç–æ–≤–∞—è
            </button>
            <button class="select-btn" data-board="dark">
                <div class="color-preview"><div style="background:#4a4a4a"></div><div style="background:#2d2d2d"></div><div style="background:#2d2d2d"></div><div style="background:#4a4a4a"></div></div>
                –¢—ë–º–Ω–∞—è
            </button>
        </div>
    </div>
    
    <div class="setting-group">
        <h3>–ê–Ω–∏–º–∞—Ü–∏–∏</h3>
        <div class="toggle-row">
            <span>–ê–Ω–∏–º–∞—Ü–∏—è –º–∞—Ç–∞</span>
            <div class="toggle on" id="toggleMateAnim" data-key="mateAnim"></div>
        </div>
        <div class="toggle-row">
            <span>–ê–Ω–∏–º–∞—Ü–∏—è –≤–∑—è—Ç–∏—è</span>
            <div class="toggle on" id="toggleCaptureAnim" data-key="captureAnim"></div>
        </div>
        <div class="toggle-row">
            <span>–ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ö–æ–¥–æ–≤</span>
            <div class="toggle on" id="toggleHighlight" data-key="highlight"></div>
        </div>
    </div>
</div>

<div class="toast" id="toast"></div>

<!-- –ê—É–¥–∏–æ -->
<audio id="sndMove" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-self.mp3" preload="auto"></audio>
<audio id="sndCapture" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/capture.mp3" preload="auto"></audio>
<audio id="sndCheck" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-check.mp3" preload="auto"></audio>
<audio id="sndCastle" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/castle.mp3" preload="auto"></audio>
<audio id="sndPromo" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/promote.mp3" preload="auto"></audio>
<audio id="sndEnd" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/game-end.mp3" preload="auto"></audio>

<script>
// –ù–∞—Å—Ç—Ä–æ–π–∫–∏
const config = {
    pieceStyle: localStorage.getItem('pieceStyle') || 'neo',
    boardColor: localStorage.getItem('boardColor') || 'green',
    mateAnim: localStorage.getItem('mateAnim') !== 'false',
    captureAnim: localStorage.getItem('captureAnim') !== 'false',
    highlight: localStorage.getItem('highlight') !== 'false',
    sound: localStorage.getItem('sound') !== 'false',
    elo: parseInt(localStorage.getItem('elo')) || 1400,
    time: localStorage.getItem('time') || '10|0',
    color: localStorage.getItem('color') || 'white'
};

// URL —Ñ–∏–≥—É—Ä
const PIECE_URLS = {
    neo: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/',
    classic: 'https://images.chesscomfiles.com/chess-themes/pieces/classic/150/',
    wood: 'https://images.chesscomfiles.com/chess-themes/pieces/wood/150/',
    glass: 'https://images.chesscomfiles.com/chess-themes/pieces/glass/150/'
};

function getPieceUrl(piece) {
    const base = PIECE_URLS[config.pieceStyle];
    const color = piece === piece.toUpperCase() ? 'w' : 'b';
    const type = piece.toLowerCase();
    return base + color + type + '.png';
}

// –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
let board = [], turn = 'w', selected = null, legalMoves = [], lastMove = null;
let gameOver = false, isAiThinking = false;
let history = [], notation = [], capturedWhite = [], capturedBlack = [];
let enPassant = null, castling = { K: true, Q: true, k: true, q: true };
let whiteTime = 600, blackTime = 600, increment = 0, timerInterval = null;
let playerColor = true, flipped = false, premove = null;
let isOnline = false, peer = null, conn = null, gameCode = null;
let analysisData = [], currentAnalysisPos = 0;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–æ–Ω–∞
function initFloatingPieces() {
    const container = document.getElementById('floatingPieces');
    const pieces = ['‚ôî','‚ôï','‚ôñ','‚ôó','‚ôò','‚ôô','‚ôö','‚ôõ','‚ôú','‚ôù','‚ôû','‚ôü'];
    for (let i = 0; i < 15; i++) {
        const el = document.createElement('div');
        el.className = 'floating-piece';
        el.textContent = pieces[Math.floor(Math.random() * pieces.length)];
        el.style.left = Math.random() * 100 + '%';
        el.style.animationDelay = Math.random() * 20 + 's';
        el.style.animationDuration = (15 + Math.random() * 10) + 's';
        container.appendChild(el);
    }
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
document.addEventListener('DOMContentLoaded', () => {
    initFloatingPieces();
    loadSettings();
    setupEventListeners();
    checkUrlParams();
});

function loadSettings() {
    document.getElementById('eloSlider').value = config.elo;
    document.getElementById('eloValue').textContent = config.elo;
    document.getElementById('soundBtn').textContent = config.sound ? 'üîä' : 'üîá';
    
    document.querySelectorAll('[data-time]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.time === config.time);
    });
    document.querySelectorAll('[data-color]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === config.color);
    });
    document.querySelectorAll('[data-style]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.style === config.pieceStyle);
    });
    document.querySelectorAll('[data-board]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.board === config.boardColor);
    });
    
    document.getElementById('toggleMateAnim').classList.toggle('on', config.mateAnim);
    document.getElementById('toggleCaptureAnim').classList.toggle('on', config.captureAnim);
    document.getElementById('toggleHighlight').classList.toggle('on', config.highlight);
    
    applyBoardColor();
}

function applyBoardColor() {
    const boards = document.querySelectorAll('#board, #board2');
    boards.forEach(b => {
        b.className = b.id === 'board2' ? '' : '';
        b.classList.add('board-' + config.boardColor);
        if (b.id === 'board2') {
            b.style.display = 'grid';
            b.style.gridTemplateColumns = 'repeat(8, 1fr)';
            b.style.aspectRatio = '1';
            b.style.borderRadius = '6px';
            b.style.overflow = 'hidden';
        }
    });
}

function setupEventListeners() {
    // –°–ª–∞–π–¥–µ—Ä
    document.getElementById('eloSlider').addEventListener('input', e => {
        config.elo = parseInt(e.target.value);
        document.getElementById('eloValue').textContent = config.elo;
        localStorage.setItem('elo', config.elo);
    });
    
    // –í—Ä–µ–º—è
    document.getElementById('timeSelect').addEventListener('click', e => {
        const btn = e.target.closest('.select-btn');
        if (!btn) return;
        document.querySelectorAll('#timeSelect .select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        config.time = btn.dataset.time;
        localStorage.setItem('time', config.time);
    });
    
    // –¶–≤–µ—Ç
    document.getElementById('colorSelect').addEventListener('click', e => {
        const btn = e.target.closest('.select-btn');
        if (!btn) return;
        document.querySelectorAll('#colorSelect .select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        config.color = btn.dataset.color;
        localStorage.setItem('color', config.color);
    });
    
    // –ö–Ω–æ–ø–∫–∏ –º–µ–Ω—é
    document.getElementById('btnPlayAI').addEventListener('click', startVsAI);
    document.getElementById('btnCreate').addEventListener('click', createOnlineGame);
    document.getElementById('btnJoin').addEventListener('click', joinOnlineGame);
    document.getElementById('btnCancelWait').addEventListener('click', cancelWaiting);
    
    // –ö–Ω–æ–ø–∫–∏ –∏–≥—Ä—ã
    document.getElementById('btnMenu').addEventListener('click', backToMenu);
    document.getElementById('btnUndo').addEventListener('click', requestUndo);
    document.getElementById('btnDraw').addEventListener('click', offerDraw);
    document.getElementById('btnResign').addEventListener('click', resign);
    
    // –ó–∞–ø—Ä–æ—Å—ã
    document.getElementById('acceptDraw').addEventListener('click', () => respondToRequest('draw', true));
    document.getElementById('declineDraw').addEventListener('click', () => respondToRequest('draw', false));
    document.getElementById('acceptUndo').addEventListener('click', () => respondToRequest('undo', true));
    document.getElementById('declineUndo').addEventListener('click', () => respondToRequest('undo', false));
    
    // –†–µ–∑—É–ª—å—Ç–∞—Ç
    document.getElementById('closeResult').addEventListener('click', () => {
        document.getElementById('resultToast').classList.remove('show');
    });
    document.getElementById('btnRematch').addEventListener('click', rematch);
    document.getElementById('btnAnalysis').addEventListener('click', startAnalysis);
    document.getElementById('btnToMenu').addEventListener('click', backToMenu);
    
    // –ü—Ä–µ–º—É–≤
    document.getElementById('premoveBar').addEventListener('click', clearPremove);
    
    // –ó–≤—É–∫
    document.getElementById('soundBtn').addEventListener('click', () => {
        config.sound = !config.sound;
        localStorage.setItem('sound', config.sound);
        document.getElementById('soundBtn').textContent = config.sound ? 'üîä' : 'üîá';
    });
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏
    document.getElementById('settingsBtn').addEventListener('click', () => {
        document.getElementById('settingsPanel').classList.add('open');
        document.getElementById('settingsOverlay').classList.add('show');
    });
    document.getElementById('closeSettings').addEventListener('click', closeSettings);
    document.getElementById('settingsOverlay').addEventListener('click', closeSettings);
    
    // –°—Ç–∏–ª—å —Ñ–∏–≥—É—Ä
    document.getElementById('pieceStyleSelect').addEventListener('click', e => {
        const btn = e.target.closest('.select-btn');
        if (!btn) return;
        document.querySelectorAll('#pieceStyleSelect .select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        config.pieceStyle = btn.dataset.style;
        localStorage.setItem('pieceStyle', config.pieceStyle);
        renderBoard();
    });
    
    // –¶–≤–µ—Ç –¥–æ—Å–∫–∏
    document.getElementById('boardColorSelect').addEventListener('click', e => {
        const btn = e.target.closest('.select-btn');
        if (!btn) return;
        document.querySelectorAll('#boardColorSelect .select-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        config.boardColor = btn.dataset.board;
        localStorage.setItem('boardColor', config.boardColor);
        applyBoardColor();
    });
    
    // –¢–æ–≥–≥–ª—ã
    document.querySelectorAll('.toggle').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('on');
            const key = toggle.dataset.key;
            config[key] = toggle.classList.contains('on');
            localStorage.setItem(key, config[key]);
        });
    });
    
    // –ê–Ω–∞–ª–∏–∑
    document.getElementById('btnBackFromAnalysis').addEventListener('click', () => {
        showScreen('gameScreen');
    });
    
    // Enter –¥–ª—è –∫–æ–¥–∞
    document.getElementById('joinCode').addEventListener('keypress', e => {
        if (e.key === 'Enter') joinOnlineGame();
    });
}

function closeSettings() {
    document.getElementById('settingsPanel').classList.remove('open');
    document.getElementById('settingsOverlay').classList.remove('show');
}

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
    
    const isGame = id === 'gameScreen' || id === 'analysisScreen';
    document.querySelector('.menu-bg').style.display = isGame ? 'none' : 'block';
    document.getElementById('floatingPieces').style.display = isGame ? 'none' : 'block';
    document.getElementById('gameBg').style.display = isGame ? 'block' : 'none';
}

function showToast(msg) {
    const toast = document.getElementById('toast');
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
}

function playSound(id) {
    if (!config.sound) return;
    const audio = document.getElementById(id);
    if (audio) {
        audio.currentTime = 0;
        audio.play().catch(() => {});
    }
}

// =============== –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ===============

function initBoard() {
    board = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    turn = 'w';
    selected = null;
    legalMoves = [];
    lastMove = null;
    gameOver = false;
    isAiThinking = false;
    history = [];
    notation = [];
    capturedWhite = [];
    capturedBlack = [];
    enPassant = null;
    castling = { K: true, Q: true, k: true, q: true };
    premove = null;
    
    const [mins, inc] = config.time.split('|').map(Number);
    whiteTime = mins * 60;
    blackTime = mins * 60;
    increment = inc;
    
    document.getElementById('drawRequest').classList.remove('show');
    document.getElementById('undoRequest').classList.remove('show');
    document.getElementById('premoveBar').classList.remove('show');
    document.getElementById('resultToast').classList.remove('show');
}

function startVsAI() {
    isOnline = false;
    playerColor = config.color === 'random' ? Math.random() < 0.5 : config.color === 'white';
    flipped = !playerColor;
    
    initBoard();
    
    document.getElementById('topName').textContent = '–ë–æ—Ç';
    document.getElementById('topAvatar').textContent = 'ü§ñ';
    document.getElementById('topRating').textContent = config.elo;
    document.getElementById('bottomRating').textContent = playerColor ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.remove('show');
    
    showScreen('gameScreen');
    renderBoard();
    updateUI();
    startTimer();
    
    if (!playerColor) {
        isAiThinking = true;
        updateUI();
        setTimeout(makeAiMove, 500);
    }
}

// =============== –û–ù–õ–ê–ô–ù ===============

function createOnlineGame() {
    gameCode = generateCode();
    document.getElementById('gameCodeDisplay').textContent = gameCode;
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('waitingRoom').classList.remove('hidden');
    
    peer = new Peer('chess-' + gameCode, {
        config: {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        }
    });
    
    peer.on('open', () => console.log('–•–æ—Å—Ç –≥–æ—Ç–æ–≤:', gameCode));
    
    peer.on('connection', c => {
        conn = c;
        setupConnection();
        
        playerColor = config.color === 'random' ? Math.random() < 0.5 : config.color === 'white';
        conn.on('open', () => {
            conn.send({ type: 'start', hostColor: playerColor ? 'white' : 'black' });
            startOnlineGame();
        });
    });
    
    peer.on('error', err => {
        console.error('Peer error:', err);
        showToast('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
        cancelWaiting();
    });
}

function joinOnlineGame() {
    const code = document.getElementById('joinCode').value.trim().toUpperCase();
    if (!code) {
        showToast('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥');
        return;
    }
    
    document.getElementById('joinStatus').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';
    document.getElementById('btnJoin').disabled = true;
    
    peer = new Peer({
        config: {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        }
    });
    
    peer.on('open', () => {
        conn = peer.connect('chess-' + code, { reliable: true });
        
        const timeout = setTimeout(() => {
            document.getElementById('joinStatus').textContent = '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
            document.getElementById('btnJoin').disabled = false;
            if (conn) conn.close();
            if (peer) peer.destroy();
        }, 12000);
        
        conn.on('open', () => {
            clearTimeout(timeout);
            setupConnection();
        });
        
        conn.on('error', () => {
            clearTimeout(timeout);
            document.getElementById('joinStatus').textContent = '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
            document.getElementById('btnJoin').disabled = false;
        });
    });
    
    peer.on('error', err => {
        document.getElementById('joinStatus').textContent = '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞';
        document.getElementById('btnJoin').disabled = false;
    });
}

function setupConnection() {
    conn.on('data', handleOnlineMessage);
    conn.on('close', () => {
        if (!gameOver) {
            document.getElementById('status').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è';
        }
    });
}

function handleOnlineMessage(data) {
    switch (data.type) {
        case 'start':
            playerColor = data.hostColor === 'white' ? false : true;
            startOnlineGame();
            break;
        case 'move':
            executeMoveFromData(data.move);
            break;
        case 'draw-offer':
            document.getElementById('drawRequest').classList.add('show');
            break;
        case 'draw-accept':
            endGame('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
            break;
        case 'draw-decline':
            showToast('–ù–∏—á—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞');
            break;
        case 'undo-request':
            document.getElementById('undoRequest').classList.add('show');
            break;
        case 'undo-accept':
            actuallyUndoMove();
            actuallyUndoMove();
            showToast('–•–æ–¥ –æ—Ç–º–µ–Ω—ë–Ω');
            break;
        case 'undo-decline':
            showToast('–û—Ç–º–µ–Ω–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞');
            break;
        case 'resign':
            endGame('win', '–°–æ–ø–µ—Ä–Ω–∏–∫ —Å–¥–∞–ª—Å—è');
            break;
    }
}

function startOnlineGame() {
    isOnline = true;
    gameCode = null;
    flipped = !playerColor;
    
    initBoard();
    
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('joinStatus').textContent = '';
    document.getElementById('btnJoin').disabled = false;
    
    document.getElementById('topName').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫';
    document.getElementById('topAvatar').textContent = 'üë§';
    document.getElementById('topRating').textContent = playerColor ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
    document.getElementById('bottomRating').textContent = playerColor ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.add('show');
    
    showScreen('gameScreen');
    renderBoard();
    updateUI();
    startTimer();
}

function cancelWaiting() {
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
    if (peer) { peer.destroy(); peer = null; }
    if (conn) { conn.close(); conn = null; }
}

function generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
}

function checkUrlParams() {
    const params = new URLSearchParams(window.location.search);
    const code = params.get('g');
    if (code) {
        document.getElementById('joinCode').value = code.toUpperCase();
        setTimeout(joinOnlineGame, 500);
    }
}

// =============== –î–û–°–ö–ê –ò –†–ï–ù–î–ï–† ===============

function renderBoard() {
    const boardEl = document.getElementById('board');
    boardEl.innerHTML = '';
    boardEl.className = 'board-' + config.boardColor;
    
    const kingPos = findKing(turn === 'w');
    const inCheck = kingPos && isSquareAttacked(kingPos.r, kingPos.c, turn !== 'w');
    
    for (let i = 0; i < 64; i++) {
        let r = Math.floor(i / 8);
        let c = i % 8;
        if (flipped) { r = 7 - r; c = 7 - c; }
        
        const sq = document.createElement('div');
        sq.className = 'sq ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
        sq.dataset.r = r;
        sq.dataset.c = c;
        
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∏
        if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');
        if (config.highlight && lastMove) {
            if ((lastMove.fr === r && lastMove.fc === c) || (lastMove.tr === r && lastMove.tc === c)) {
                sq.classList.add('last-move');
            }
        }
        if (inCheck && kingPos.r === r && kingPos.c === c) sq.classList.add('check');
        if (premove) {
            if ((premove.fr === r && premove.fc === c) || (premove.tr === r && premove.tc === c)) {
                sq.classList.add('premove');
            }
        }
        
        // –í–æ–∑–º–æ–∂–Ω—ã–µ —Ö–æ–¥—ã
        if (config.highlight) {
            for (const m of legalMoves) {
                if (m.tr === r && m.tc === c) {
                    sq.classList.add(board[r][c] ? 'can-capture' : 'can-move');
                    break;
                }
            }
        }
        
        // –§–∏–≥—É—Ä–∞
        if (board[r][c]) {
            const img = document.createElement('img');
            img.src = getPieceUrl(board[r][c]);
            img.className = 'piece';
            img.draggable = false;
            sq.appendChild(img);
        }
        
        // –°–æ–±—ã—Ç–∏—è
        sq.addEventListener('mousedown', e => startDrag(e, r, c));
        sq.addEventListener('touchstart', e => startDrag(e, r, c), { passive: false });
        sq.addEventListener('click', () => handleSquareClick(r, c));
        
        boardEl.appendChild(sq);
    }
    
    updateCaptured();
    updateMoveList();
    updateTimers();
}

// =============== DRAG & DROP ===============

let dragging = false;
let dragPiece = null;
let dragStartR = -1, dragStartC = -1;

function startDrag(e, r, c) {
    if (gameOver) return;
    
    const piece = board[r][c];
    if (!piece) return;
    
    const isMyPiece = (piece === piece.toUpperCase()) === playerColor;
    const isMyTurn = (turn === 'w') === playerColor;
    
    // –î–ª—è –ø—Ä–µ–º—É–≤–∞ - –º–æ–∂–Ω–æ –±—Ä–∞—Ç—å —Å–≤–æ–∏ —Ñ–∏–≥—É—Ä—ã –Ω–µ –≤ —Å–≤–æ–π —Ö–æ–¥
    if (!isMyPiece) return;
    if (!isMyTurn && !isOnline) return; // –ü—Ä–æ—Ç–∏–≤ –ò–ò –Ω–µ–ª—å–∑—è –ø—Ä–µ–º—É–≤
    
    e.preventDefault();
    
    dragging = true;
    dragStartR = r;
    dragStartC = c;
    dragPiece = piece;
    
    // –í—ã–±–æ—Ä –∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∞
    selected = { r, c };
    legalMoves = isMyTurn ? getMoves(r, c) : getMoves(r, c, false); // –î–ª—è –ø—Ä–µ–º—É–≤–∞ –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–µ–≥–∞–ª—å–Ω–æ—Å—Ç–∏
    
    // –ü–æ–¥—Å–≤–µ—Ç–∏—Ç—å –∏—Å—Ö–æ–¥–Ω—É—é –∫–ª–µ—Ç–∫—É
    const sq = document.querySelector(`.sq[data-r="${r}"][data-c="${c}"]`);
    if (sq) sq.classList.add('dragging');
    
    // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–∑—Ä–∞–∫
    const ghost = document.getElementById('dragGhost');
    ghost.src = getPieceUrl(piece);
    ghost.classList.add('visible');
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    ghost.style.left = (clientX - 35) + 'px';
    ghost.style.top = (clientY - 35) + 'px';
    
    renderBoard();
    
    document.addEventListener('mousemove', moveDrag);
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchmove', moveDrag, { passive: false });
    document.addEventListener('touchend', endDrag);
}

function moveDrag(e) {
    if (!dragging) return;
    e.preventDefault();
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const ghost = document.getElementById('dragGhost');
    ghost.style.left = (clientX - 35) + 'px';
    ghost.style.top = (clientY - 35) + 'px';
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ü–µ–ª–µ–≤–æ–π –∫–ª–µ—Ç–∫–∏
    document.querySelectorAll('.sq.drag-over').forEach(s => s.classList.remove('drag-over'));
    const el = document.elementFromPoint(clientX, clientY);
    if (el && el.classList.contains('sq')) {
        el.classList.add('drag-over');
    }
}

function endDrag(e) {
    if (!dragging) return;
    
    document.removeEventListener('mousemove', moveDrag);
    document.removeEventListener('mouseup', endDrag);
    document.removeEventListener('touchmove', moveDrag);
    document.removeEventListener('touchend', endDrag);
    
    const ghost = document.getElementById('dragGhost');
    ghost.classList.remove('visible');
    
    document.querySelectorAll('.sq.dragging').forEach(s => s.classList.remove('dragging'));
    document.querySelectorAll('.sq.drag-over').forEach(s => s.classList.remove('drag-over'));
    
    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
    const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
    
    const el = document.elementFromPoint(clientX, clientY);
    if (el && el.classList.contains('sq')) {
        const tr = parseInt(el.dataset.r);
        const tc = parseInt(el.dataset.c);
        
        if (tr !== dragStartR || tc !== dragStartC) {
            tryMove(dragStartR, dragStartC, tr, tc);
        }
    }
    
    dragging = false;
    dragPiece = null;
    selected = null;
    legalMoves = [];
    renderBoard();
}

function handleSquareClick(r, c) {
    if (dragging || gameOver) return;
    
    const isMyTurn = (turn === 'w') === playerColor;
    
    // –ï—Å–ª–∏ —É–∂–µ –≤—ã–±—Ä–∞–Ω–∞ —Ñ–∏–≥—É—Ä–∞
    if (selected) {
        if (selected.r === r && selected.c === c) {
            selected = null;
            legalMoves = [];
            renderBoard();
            return;
        }
        
        tryMove(selected.r, selected.c, r, c);
        selected = null;
        legalMoves = [];
        renderBoard();
        return;
    }
    
    // –í—ã–±–æ—Ä —Ñ–∏–≥—É—Ä—ã
    const piece = board[r][c];
    if (!piece) return;
    
    const isMyPiece = (piece === piece.toUpperCase()) === playerColor;
    if (!isMyPiece) return;
    
    if (!isMyTurn && isOnline) {
        // –í—ã–±–æ—Ä –¥–ª—è –ø—Ä–µ–º—É–≤–∞
        selected = { r, c };
        legalMoves = getMoves(r, c, false);
        renderBoard();
        return;
    }
    
    if (!isMyTurn) return;
    
    selected = { r, c };
    legalMoves = getMoves(r, c);
    renderBoard();
}

function tryMove(fr, fc, tr, tc) {
    const isMyTurn = (turn === 'w') === playerColor;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ª–µ–≥–∞–ª—å–Ω—ã–π —Ö–æ–¥
    const move = legalMoves.find(m => m.tr === tr && m.tc === tc);
    
    if (!isMyTurn && isOnline) {
        // –ü—Ä–µ–º—É–≤
        if (move || getMoves(fr, fc, false).find(m => m.tr === tr && m.tc === tc)) {
            setPremove(fr, fc, tr, tc);
        }
        return;
    }
    
    if (!move) return;
    
    // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –ø–µ—à–∫–∏
    if (move.promo) {
        showPromoModal(move);
        return;
    }
    
    executeMove(move);
}

// =============== –ü–†–ï–ú–£–í ===============

function setPremove(fr, fc, tr, tc) {
    premove = { fr, fc, tr, tc };
    document.getElementById('premoveBar').classList.add('show');
    playSound('sndMove');
    renderBoard();
}

function clearPremove() {
    premove = null;
    document.getElementById('premoveBar').classList.remove('show');
    renderBoard();
}

function executePremove() {
    if (!premove) return;
    
    const { fr, fc, tr, tc } = premove;
    clearPremove();
    
    const piece = board[fr][fc];
    if (!piece) return;
    if ((piece === piece.toUpperCase()) !== playerColor) return;
    
    const moves = getMoves(fr, fc);
    const move = moves.find(m => m.tr === tr && m.tc === tc);
    
    if (move) {
        if (move.promo) {
            // –ê–≤—Ç–æ-—Ñ–µ—Ä–∑—å –¥–ª—è –ø—Ä–µ–º—É–≤–∞
            move.promoTo = 'q';
        }
        executeMove(move);
    }
}

// =============== –•–û–î–´ ===============

function executeMove(move, fromOnline = false) {
    const piece = board[move.fr][move.fc];
    const captured = board[move.tr][move.tc];
    const isWhite = piece === piece.toUpperCase();
    
    // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –∏—Å—Ç–æ—Ä–∏—é
    history.push({
        move: { ...move },
        piece,
        captured,
        enPassant: enPassant ? { ...enPassant } : null,
        castling: { ...castling },
        epCapture: null
    });
    
    // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ
    let epCapture = null;
    if (move.ep) {
        const epR = isWhite ? move.tr + 1 : move.tr - 1;
        epCapture = board[epR][move.tc];
        board[epR][move.tc] = '';
        history[history.length - 1].epCapture = epCapture;
    }
    
    // –í–∑—è—Ç–∏–µ
    if (captured) {
        (isWhite ? capturedWhite : capturedBlack).push(captured);
        if (config.captureAnim && !fromOnline) {
            animateCapture(move.tr, move.tc);
        }
    }
    if (epCapture) {
        (isWhite ? capturedWhite : capturedBlack).push(epCapture);
    }
    
    // –í—ã–ø–æ–ª–Ω–∏—Ç—å —Ö–æ–¥
    board[move.tr][move.tc] = piece;
    board[move.fr][move.fc] = '';
    
    // –†–æ–∫–∏—Ä–æ–≤–∫–∞
    if (move.castle) {
        const row = move.tr;
        if (move.castle === 'k') {
            board[row][5] = board[row][7];
            board[row][7] = '';
        } else {
            board[row][3] = board[row][0];
            board[row][0] = '';
        }
    }
    
    // –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ
    if (move.promo) {
        const promoTo = move.promoTo || 'q';
        board[move.tr][move.tc] = isWhite ? promoTo.toUpperCase() : promoTo.toLowerCase();
    }
    
    // –û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–∞–≤–∞ —Ä–æ–∫–∏—Ä–æ–≤–∫–∏
    if (piece === 'K') { castling.K = false; castling.Q = false; }
    if (piece === 'k') { castling.k = false; castling.q = false; }
    if (move.fr === 7 && move.fc === 0) castling.Q = false;
    if (move.fr === 7 && move.fc === 7) castling.K = false;
    if (move.fr === 0 && move.fc === 0) castling.q = false;
    if (move.fr === 0 && move.fc === 7) castling.k = false;
    
    // –í–∑—è—Ç–∏–µ –Ω–∞ –ø—Ä–æ—Ö–æ–¥–µ - —Ü–µ–ª—å
    enPassant = move.dbl ? { r: (move.fr + move.tr) / 2, c: move.fc } : null;
    
    // –ù–æ—Ç–∞—Ü–∏—è
    addNotation(move, piece, captured || epCapture);
    
    lastMove = move;
    turn = turn === 'w' ? 'b' : 'w';
    
    // –ó–≤—É–∫–∏
    if (move.promo) playSound('sndPromo');
    else if (move.castle) playSound('sndCastle');
    else if (captured || epCapture) playSound('sndCapture');
    else playSound('sndMove');
    
    // –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç
    if (isWhite) whiteTime += increment;
    else blackTime += increment;
    
    renderBoard();
    updateUI();
    
    // –®–∞—Ö?
    setTimeout(() => {
        const kingPos = findKing(turn === 'w');
        if (kingPos && isSquareAttacked(kingPos.r, kingPos.c, turn !== 'w')) {
            playSound('sndCheck');
        }
    }, 50);
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–Ω–ª–∞–π–Ω
    if (isOnline && conn && !fromOnline) {
        conn.send({ type: 'move', move: { ...move } });
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
    if (checkGameEnd()) return;
    
    // –ò–ò –∏–ª–∏ –ø—Ä–µ–º—É–≤
    if (!isOnline && (turn === 'w') !== playerColor) {
        isAiThinking = true;
        updateUI();
        setTimeout(makeAiMove, 300);
    } else if (isOnline && (turn === 'w') === playerColor && premove) {
        setTimeout(executePremove, 100);
    }
}

function executeMoveFromData(moveData) {
    const move = { ...moveData };
    executeMove(move, true);
}

function animateCapture(r, c) {
    // –ü—Ä–æ—Å—Ç–∞—è –≤—Å–ø—ã—à–∫–∞
    const sq = document.querySelector(`.sq[data-r="${r}"][data-c="${c}"]`);
    if (sq) {
        sq.style.transition = 'none';
        sq.style.boxShadow = 'inset 0 0 30px rgba(255,0,0,0.5)';
        setTimeout(() => {
            sq.style.transition = 'box-shadow 0.3s';
            sq.style.boxShadow = 'none';
        }, 100);
    }
}

function addNotation(move, piece, captured) {
    const files = 'abcdefgh';
    const ranks = '87654321';
    
    let san = '';
    if (move.castle === 'k') san = 'O-O';
    else if (move.castle === 'q') san = 'O-O-O';
    else {
        if (piece.toUpperCase() !== 'P') san += piece.toUpperCase();
        if (captured) {
            if (piece.toUpperCase() === 'P') san += files[move.fc];
            san += 'x';
        }
        san += files[move.tc] + ranks[move.tr];
        if (move.promo) san += '=' + (move.promoTo || 'Q').toUpperCase();
    }
    
    notation.push(san);
}

function showPromoModal(move) {
    const modal = document.getElementById('promoModal');
    const opts = document.getElementById('promoOpts');
    opts.innerHTML = '';
    
    const isWhite = turn === 'w';
    const pieces = ['q', 'r', 'b', 'n'];
    
    pieces.forEach(p => {
        const piece = isWhite ? p.toUpperCase() : p;
        const div = document.createElement('div');
        div.className = 'promo-opt';
        div.style.background = isWhite ? '#eee' : '#333';
        
        const img = document.createElement('img');
        img.src = getPieceUrl(piece);
        div.appendChild(img);
        
        div.addEventListener('click', () => {
            modal.classList.remove('show');
            move.promoTo = p;
            executeMove(move);
        });
        
        opts.appendChild(div);
    });
    
    modal.classList.add('show');
}

// =============== –ì–ï–ù–ï–†–ê–¶–ò–Ø –•–û–î–û–í ===============

function getMoves(r, c, checkLegal = true) {
    const piece = board[r][c];
    if (!piece) return [];
    
    const isWhite = piece === piece.toUpperCase();
    const type = piece.toLowerCase();
    let moves = [];
    
    if (type === 'p') {
        const dir = isWhite ? -1 : 1;
        const startRow = isWhite ? 6 : 1;
        const promoRow = isWhite ? 0 : 7;
        
        // –í–ø–µ—Ä—ë–¥
        if (board[r + dir] && !board[r + dir][c]) {
            moves.push({ fr: r, fc: c, tr: r + dir, tc: c, promo: r + dir === promoRow });
            // –î–≤–æ–π–Ω–æ–π
            if (r === startRow && !board[r + 2 * dir][c]) {
                moves.push({ fr: r, fc: c, tr: r + 2 * dir, tc: c, dbl: true });
            }
        }
        
        // –í–∑—è—Ç–∏—è
        [-1, 1].forEach(dc => {
            const nc = c + dc;
            if (nc < 0 || nc > 7) return;
            if (board[r + dir] && board[r + dir][nc]) {
                const target = board[r + dir][nc];
                if ((isWhite && target === target.toLowerCase()) || (!isWhite && target === target.toUpperCase())) {
                    moves.push({ fr: r, fc: c, tr: r + dir, tc: nc, promo: r + dir === promoRow });
                }
            }
            // –ù–∞ –ø—Ä–æ—Ö–æ–¥–µ
            if (enPassant && enPassant.r === r + dir && enPassant.c === nc) {
                moves.push({ fr: r, fc: c, tr: r + dir, tc: nc, ep: true });
            }
        });
    }
    
    if (type === 'n') {
        const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        offsets.forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            if (nr < 0 || nr > 7 || nc < 0 || nc > 7) return;
            const target = board[nr][nc];
            if (!target || (isWhite ? target === target.toLowerCase() : target === target.toUpperCase())) {
                moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            }
        });
    }
    
    if (type === 'b' || type === 'q') {
        [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr, dc]) => {
            let nr = r + dr, nc = c + dc;
            while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                const target = board[nr][nc];
                if (target && (isWhite ? target === target.toUpperCase() : target === target.toLowerCase())) break;
                moves.push({ fr: r, fc: c, tr: nr, tc: nc });
                if (target) break;
                nr += dr; nc += dc;
            }
        });
    }
    
    if (type === 'r' || type === 'q') {
        [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr, dc]) => {
            let nr = r + dr, nc = c + dc;
            while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                const target = board[nr][nc];
                if (target && (isWhite ? target === target.toUpperCase() : target === target.toLowerCase())) break;
                moves.push({ fr: r, fc: c, tr: nr, tc: nc });
                if (target) break;
                nr += dr; nc += dc;
            }
        });
    }
    
    if (type === 'k') {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr, nc = c + dc;
                if (nr < 0 || nr > 7 || nc < 0 || nc > 7) continue;
                const target = board[nr][nc];
                if (!target || (isWhite ? target === target.toLowerCase() : target === target.toUpperCase())) {
                    moves.push({ fr: r, fc: c, tr: nr, tc: nc });
                }
            }
        }
        
        // –†–æ–∫–∏—Ä–æ–≤–∫–∞
        if (checkLegal) {
            const row = isWhite ? 7 : 0;
            const kingside = isWhite ? castling.K : castling.k;
            const queenside = isWhite ? castling.Q : castling.q;
            
            if (kingside && !board[row][5] && !board[row][6]) {
                if (!isSquareAttacked(row, 4, !isWhite) && !isSquareAttacked(row, 5, !isWhite) && !isSquareAttacked(row, 6, !isWhite)) {
                    moves.push({ fr: row, fc: 4, tr: row, tc: 6, castle: 'k' });
                }
            }
            if (queenside && !board[row][1] && !board[row][2] && !board[row][3]) {
                if (!isSquareAttacked(row, 4, !isWhite) && !isSquareAttacked(row, 3, !isWhite) && !isSquareAttacked(row, 2, !isWhite)) {
                    moves.push({ fr: row, fc: 4, tr: row, tc: 2, castle: 'q' });
                }
            }
        }
    }
    
    if (checkLegal) {
        moves = moves.filter(m => isLegalMove(m, isWhite));
    }
    
    return moves;
}

function isLegalMove(move, isWhite) {
    // –í—Ä–µ–º–µ–Ω–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Ö–æ–¥
    const piece = board[move.fr][move.fc];
    const captured = board[move.tr][move.tc];
    
    board[move.tr][move.tc] = piece;
    board[move.fr][move.fc] = '';
    
    let epCap = null;
    if (move.ep) {
        const epR = isWhite ? move.tr + 1 : move.tr - 1;
        epCap = board[epR][move.tc];
        board[epR][move.tc] = '';
    }
    
    const kingPos = findKing(isWhite);
    const legal = !kingPos || !isSquareAttacked(kingPos.r, kingPos.c, !isWhite);
    
    // –û—Ç–∫–∞—Ç–∏—Ç—å
    board[move.fr][move.fc] = piece;
    board[move.tr][move.tc] = captured;
    if (epCap !== null) {
        board[isWhite ? move.tr + 1 : move.tr - 1][move.tc] = epCap;
    }
    
    return legal;
}

function findKing(isWhite) {
    const king = isWhite ? 'K' : 'k';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (board[r][c] === king) return { r, c };
        }
    }
    return null;
}

function isSquareAttacked(r, c, byWhite) {
    for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
            const piece = board[i][j];
            if (!piece) continue;
            if ((piece === piece.toUpperCase()) !== byWhite) continue;
            
            const moves = getMoves(i, j, false);
            if (moves.some(m => m.tr === r && m.tc === c)) return true;
        }
    }
    return false;
}

function getAllMoves(isWhite) {
    let allMoves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (!piece) continue;
            if ((piece === piece.toUpperCase()) !== isWhite) continue;
            allMoves = allMoves.concat(getMoves(r, c));
        }
    }
    return allMoves;
}

// =============== –ö–û–ù–ï–¶ –ò–ì–†–´ ===============

function checkGameEnd() {
    const isWhiteTurn = turn === 'w';
    const moves = getAllMoves(isWhiteTurn);
    
    if (moves.length === 0) {
        const kingPos = findKing(isWhiteTurn);
        const inCheck = kingPos && isSquareAttacked(kingPos.r, kingPos.c, !isWhiteTurn);
        
        if (inCheck) {
            // –ú–∞—Ç
            const loserIsPlayer = isWhiteTurn === playerColor;
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è –∫–æ—Ä–æ–ª—è
            if (config.mateAnim && kingPos) {
                const sq = document.querySelector(`.sq[data-r="${kingPos.r}"][data-c="${kingPos.c}"]`);
                if (sq) {
                    const img = sq.querySelector('img');
                    if (img) img.classList.add('fallen');
                }
            }
            
            setTimeout(() => {
                endGame(loserIsPlayer ? 'lose' : 'win', '–ú–∞—Ç');
            }, config.mateAnim ? 800 : 100);
        } else {
            endGame('draw', '–ü–∞—Ç');
        }
        return true;
    }
    
    return false;
}

function endGame(result, reason) {
    gameOver = true;
    stopTimer();
    playSound('sndEnd');
    
    const icons = { win: 'üèÜ', lose: 'üò¢', draw: 'ü§ù' };
    const titles = { win: '–ü–æ–±–µ–¥–∞!', lose: '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ', draw: '–ù–∏—á—å—è' };
    
    document.getElementById('resultIcon').textContent = icons[result];
    document.getElementById('resultTitle').textContent = titles[result];
    document.getElementById('resultMsg').textContent = reason;
    document.getElementById('resultToast').classList.add('show');
}

function rematch() {
    document.getElementById('resultToast').classList.remove('show');
    if (isOnline) {
        // –î–ª—è –æ–Ω–ª–∞–π–Ω–∞ –ø—Ä–æ—Å—Ç–æ —Å–±—Ä–æ—Å–∏—Ç—å
        initBoard();
        renderBoard();
        updateUI();
        startTimer();
    } else {
        startVsAI();
    }
}

function backToMenu() {
    stopTimer();
    gameOver = true;
    document.getElementById('resultToast').classList.remove('show');
    
    if (peer) { peer.destroy(); peer = null; }
    if (conn) { conn.close(); conn = null; }
    isOnline = false;
    
    showScreen('menuScreen');
}

// =============== –ó–ê–ü–†–û–°–´ ===============

function offerDraw() {
    if (gameOver) return;
    
    if (isOnline && conn) {
        conn.send({ type: 'draw-offer' });
        showToast('–ù–∏—á—å—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞');
    } else {
        // –ò–ò: —Å–ª—É—á–∞–π–Ω–æ —Å–æ–≥–ª–∞—à–∞–µ—Ç—Å—è –µ—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è —Ä–∞–≤–Ω–∞—è
        const ev = evaluate();
        if (Math.abs(ev) < 150 && Math.random() < 0.3) {
            endGame('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
        } else {
            showToast('–ò–ò –æ—Ç–∫–ª–æ–Ω–∏–ª –Ω–∏—á—å—é');
        }
    }
}

function requestUndo() {
    if (gameOver || history.length < 2) return;
    
    if (isOnline && conn) {
        conn.send({ type: 'undo-request' });
        showToast('–ó–∞–ø—Ä–æ—Å –æ—Ç–º–µ–Ω—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');
    } else {
        // –ü—Ä–æ—Ç–∏–≤ –ò–ò - —Å—Ä–∞–∑—É –æ—Ç–º–µ–Ω–∏—Ç—å 2 —Ö–æ–¥–∞
        actuallyUndoMove();
        actuallyUndoMove();
        renderBoard();
        updateUI();
    }
}

function actuallyUndoMove() {
    if (history.length === 0) return;
    
    const h = history.pop();
    notation.pop();
    
    board[h.move.fr][h.move.fc] = h.piece;
    board[h.move.tr][h.move.tc] = h.captured;
    
    if (h.epCapture) {
        const epR = h.piece === h.piece.toUpperCase() ? h.move.tr + 1 : h.move.tr - 1;
        board[epR][h.move.tc] = h.epCapture;
    }
    
    if (h.move.castle) {
        const row = h.move.tr;
        if (h.move.castle === 'k') {
            board[row][7] = board[row][5];
            board[row][5] = '';
        } else {
            board[row][0] = board[row][3];
            board[row][3] = '';
        }
    }
    
    // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–µ
    if (h.captured) {
        const isWhite = h.piece === h.piece.toUpperCase();
        const arr = isWhite ? capturedWhite : capturedBlack;
        arr.pop();
    }
    if (h.epCapture) {
        const isWhite = h.piece === h.piece.toUpperCase();
        const arr = isWhite ? capturedWhite : capturedBlack;
        arr.pop();
    }
    
    enPassant = h.enPassant;
    castling = { ...h.castling };
    turn = turn === 'w' ? 'b' : 'w';
    lastMove = history.length > 0 ? history[history.length - 1].move : null;
}

function resign() {
    if (gameOver) return;
    
    if (isOnline && conn) {
        conn.send({ type: 'resign' });
    }
    endGame('lose', '–í—ã —Å–¥–∞–ª–∏—Å—å');
}

function respondToRequest(type, accept) {
    document.getElementById(type === 'draw' ? 'drawRequest' : 'undoRequest').classList.remove('show');
    
    if (isOnline && conn) {
        conn.send({ type: type + '-' + (accept ? 'accept' : 'decline') });
    }
    
    if (accept) {
        if (type === 'draw') {
            endGame('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
        } else {
            actuallyUndoMove();
            actuallyUndoMove();
            renderBoard();
            updateUI();
        }
    }
}

// =============== –¢–ê–ô–ú–ï–†–´ ===============

function startTimer() {
    const [mins] = config.time.split('|').map(Number);
    if (mins === 0) {
        document.getElementById('topTimer').classList.add('hidden');
        document.getElementById('bottomTimer').classList.add('hidden');
        return;
    }
    
    document.getElementById('topTimer').classList.remove('hidden');
    document.getElementById('bottomTimer').classList.remove('hidden');
    
    stopTimer();
    timerInterval = setInterval(() => {
        if (gameOver || isAiThinking) return;
        
        if (turn === 'w') {
            whiteTime = Math.max(0, whiteTime - 0.1);
            if (whiteTime === 0) timeOut(true);
        } else {
            blackTime = Math.max(0, blackTime - 0.1);
            if (blackTime === 0) timeOut(false);
        }
        
        updateTimers();
    }, 100);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function timeOut(isWhite) {
    gameOver = true;
    stopTimer();
    const playerLost = isWhite === playerColor;
    endGame(playerLost ? 'lose' : 'win', '–í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ');
}

function updateTimers() {
    const topIsBlack = playerColor;
    const topTime = topIsBlack ? blackTime : whiteTime;
    const bottomTime = topIsBlack ? whiteTime : blackTime;
    
    document.getElementById('topTimer').textContent = formatTime(topTime);
    document.getElementById('bottomTimer').textContent = formatTime(bottomTime);
    
    const isWhiteTurn = turn === 'w';
    const topActive = topIsBlack ? !isWhiteTurn : isWhiteTurn;
    
    document.getElementById('topTimer').classList.toggle('inactive', !topActive || gameOver);
    document.getElementById('bottomTimer').classList.toggle('inactive', topActive || gameOver);
    document.getElementById('topTimer').classList.toggle('low', topTime <= 30 && topActive);
    document.getElementById('bottomTimer').classList.toggle('low', bottomTime <= 30 && !topActive);
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
}

// =============== UI ===============

function updateUI() {
    const isMyTurn = (turn === 'w') === playerColor;
    
    document.getElementById('bottomPlayer').classList.toggle('active', isMyTurn && !gameOver);
    document.getElementById('topPlayer').classList.toggle('active', !isMyTurn && !gameOver);
    
    let status = '–í–∞—à —Ö–æ–¥';
    if (gameOver) status = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
    else if (isOnline) status = isMyTurn ? '–í–∞—à —Ö–æ–¥' : '–•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...';
    else if (isAiThinking) status = '–ò–ò –¥—É–º–∞–µ—Ç...';
    
    document.getElementById('status').textContent = status;
}

function updateCaptured() {
    const sort = arr => arr.slice().sort((a, b) => {
        const order = { q: 0, r: 1, b: 2, n: 3, p: 4 };
        return (order[a.toLowerCase()] || 5) - (order[b.toLowerCase()] || 5);
    });
    
    const render = arr => arr.map(p => `<img src="${getPieceUrl(p)}">`).join('');
    
    document.getElementById(flipped ? 'topCaptured' : 'bottomCaptured').innerHTML = render(sort(capturedBlack));
    document.getElementById(flipped ? 'bottomCaptured' : 'topCaptured').innerHTML = render(sort(capturedWhite));
}

function updateMoveList() {
    let html = '';
    for (let i = 0; i < notation.length; i += 2) {
        html += `<span><span class="move-num">${i/2+1}.</span> ${notation[i]}${notation[i+1] ? ' ' + notation[i+1] : ''} </span>`;
    }
    document.getElementById('movesList').innerHTML = html;
}

// =============== –ò–ò ===============

const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

const PST = {
    p: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
    n: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
    b: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,10,10,10,10,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,5,10,10,5,0,-10],[-10,0,5,5,5,5,0,-10],[-10,0,0,0,0,0,0,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
    r: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
    q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
    k: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
};

function evaluate() {
    let score = 0;
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (!piece) continue;
            const isWhite = piece === piece.toUpperCase();
            const type = piece.toLowerCase();
            let value = PIECE_VALUES[type] || 0;
            if (PST[type]) value += PST[type][isWhite ? r : 7 - r][c];
            score += isWhite ? value : -value;
        }
    }
    return score;
}

function makeAiMove() {
    if (gameOver) { isAiThinking = false; return; }
    
    const isAiWhite = !playerColor;
    const moves = getAllMoves(isAiWhite);
    
    if (moves.length === 0) { isAiThinking = false; return; }
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ—Ç—Å–µ—á–µ–Ω–∏—è
    moves.sort((a, b) => {
        let scoreA = 0, scoreB = 0;
        if (board[a.tr][a.tc]) scoreA += PIECE_VALUES[board[a.tr][a.tc].toLowerCase()] || 0;
        if (board[b.tr][b.tc]) scoreB += PIECE_VALUES[board[b.tr][b.tc].toLowerCase()] || 0;
        if (a.promo) scoreA += 800;
        if (b.promo) scoreB += 800;
        return scoreB - scoreA;
    });
    
    const depth = config.elo < 800 ? 1 : config.elo < 1500 ? 2 : config.elo < 2200 ? 3 : 4;
    const randomness = Math.max(5, 80 - config.elo / 35);
    
    let bestMove = moves[0];
    let bestScore = -Infinity;
    
    for (const move of moves) {
        const state = saveState();
        simulateMove(move);
        const score = -minimax(depth - 1, -Infinity, Infinity, !isAiWhite) + (Math.random() - 0.5) * randomness;
        restoreState(state);
        
        if (score > bestScore) {
            bestScore = score;
            bestMove = move;
        }
    }
    
    if (bestMove.promo) bestMove.promoTo = 'q';
    
    isAiThinking = false;
    executeMove(bestMove);
}

function minimax(depth, alpha, beta, isMaximizing) {
    if (depth === 0) return evaluate();
    
    const moves = getAllMoves(isMaximizing);
    if (moves.length === 0) {
        const kingPos = findKing(isMaximizing);
        if (kingPos && isSquareAttacked(kingPos.r, kingPos.c, !isMaximizing)) {
            return isMaximizing ? -15000 + (4 - depth) * 100 : 15000 - (4 - depth) * 100;
        }
        return 0;
    }
    
    if (isMaximizing) {
        let maxScore = -Infinity;
        for (const move of moves) {
            const state = saveState();
            simulateMove(move);
            const score = minimax(depth - 1, alpha, beta, false);
            restoreState(state);
            maxScore = Math.max(maxScore, score);
            alpha = Math.max(alpha, score);
            if (beta <= alpha) break;
        }
        return maxScore;
    } else {
        let minScore = Infinity;
        for (const move of moves) {
            const state = saveState();
            simulateMove(move);
            const score = minimax(depth - 1, alpha, beta, true);
            restoreState(state);
            minScore = Math.min(minScore, score);
            beta = Math.min(beta, score);
            if (beta <= alpha) break;
        }
        return minScore;
    }
}

function simulateMove(move) {
    const piece = board[move.fr][move.fc];
    board[move.tr][move.tc] = move.promo ? (piece === piece.toUpperCase() ? 'Q' : 'q') : piece;
    board[move.fr][move.fc] = '';
    
    if (move.ep) {
        const epR = piece === piece.toUpperCase() ? move.tr + 1 : move.tr - 1;
        board[epR][move.tc] = '';
    }
    
    if (move.castle) {
        const row = move.tr;
        if (move.castle === 'k') { board[row][5] = board[row][7]; board[row][7] = ''; }
        else { board[row][3] = board[row][0]; board[row][0] = ''; }
    }
    
    turn = turn === 'w' ? 'b' : 'w';
}

function saveState() {
    return {
        board: board.map(r => [...r]),
        turn,
        enPassant: enPassant ? { ...enPassant } : null,
        castling: { ...castling }
    };
}

function restoreState(state) {
    board = state.board.map(r => [...r]);
    turn = state.turn;
    enPassant = state.enPassant;
    castling = { ...state.castling };
}

// =============== –ê–ù–ê–õ–ò–ó ===============

function startAnalysis() {
    if (notation.length === 0) {
        showToast('–ù–µ—Ç —Ö–æ–¥–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞');
        return;
    }
    
    document.getElementById('resultToast').classList.remove('show');
    showScreen('analysisScreen');
    
    document.getElementById('analysisProgress').style.display = 'block';
    document.getElementById('analysisMoves').style.display = 'none';
    document.getElementById('analysisCount').textContent = '0';
    document.getElementById('analysisTotal').textContent = notation.length;
    
    analyzeGame();
}

async function analyzeGame() {
    // –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ - –ø—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ evaluate()
    // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–µ–Ω Stockfish —á–µ—Ä–µ–∑ Web Worker
    
    analysisData = [];
    
    // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    const currentState = saveState();
    const currentHistory = [...history];
    const currentNotation = [...notation];
    
    // –°–±—Ä–æ—Å–∏—Ç—å –¥–æ—Å–∫—É
    initBoard();
    
    let positions = [{ fen: 'startpos', eval: 0 }];
    
    // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –≤—Å–µ —Ö–æ–¥—ã
    for (let i = 0; i < currentHistory.length; i++) {
        const h = currentHistory[i];
        simulateMove(h.move);
        
        const ev = evaluate();
        positions.push({ 
            fen: `pos${i}`,
            eval: ev,
            move: currentNotation[i]
        });
        
        document.getElementById('analysisCount').textContent = i + 1;
        
        // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è UI
        await new Promise(r => setTimeout(r, 50));
    }
    
    // –ö–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å —Ö–æ–¥—ã
    for (let i = 1; i < positions.length; i++) {
        const prev = positions[i - 1].eval;
        const curr = positions[i].eval;
        const isWhiteMove = i % 2 === 1;
        
        let diff = isWhiteMove ? (curr - prev) : (prev - curr);
        let classification;
        
        if (diff > 50) classification = 'brilliant';
        else if (diff > 20) classification = 'great';
        else if (diff > -25) classification = 'best';
        else if (diff > -50) classification = 'inaccuracy';
        else if (diff > -150) classification = 'mistake';
        else classification = 'blunder';
        
        analysisData.push({
            num: i,
            san: positions[i].move,
            eval: curr,
            class: classification
        });
    }
    
    // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    restoreState(currentState);
    history.length = 0;
    history.push(...currentHistory);
    notation.length = 0;
    notation.push(...currentNotation);
    
    // –ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    displayAnalysis();
}

function displayAnalysis() {
    document.getElementById('analysisProgress').style.display = 'none';
    document.getElementById('analysisMoves').style.display = 'block';
    
    // –ü–æ—Å—á–∏—Ç–∞—Ç—å —Ç–æ—á–Ω–æ—Å—Ç—å
    let whiteGood = 0, whiteTotal = 0;
    let blackGood = 0, blackTotal = 0;
    
    analysisData.forEach((m, i) => {
        const isWhite = i % 2 === 0;
        if (isWhite) {
            whiteTotal++;
            if (['brilliant', 'great', 'best'].includes(m.class)) whiteGood++;
        } else {
            blackTotal++;
            if (['brilliant', 'great', 'best'].includes(m.class)) blackGood++;
        }
    });
    
    const whiteAcc = whiteTotal > 0 ? Math.round((whiteGood / whiteTotal) * 100) : 0;
    const blackAcc = blackTotal > 0 ? Math.round((blackGood / blackTotal) * 100) : 0;
    
    document.getElementById('whiteAccuracy').textContent = whiteAcc + '%';
    document.getElementById('blackAccuracy').textContent = blackAcc + '%';
    
    // –°–ø–∏—Å–æ–∫ —Ö–æ–¥–æ–≤
    const movesEl = document.getElementById('analysisMoves');
    movesEl.innerHTML = '';
    
    const classSymbols = {
        brilliant: '!!',
        great: '!',
        best: '‚úì',
        good: '‚úì',
        inaccuracy: '?!',
        mistake: '?',
        blunder: '??'
    };
    
    analysisData.forEach((m, i) => {
        const div = document.createElement('div');
        div.className = 'analysis-move';
        
        const evalStr = m.eval > 0 ? '+' + (m.eval / 100).toFixed(1) : (m.eval / 100).toFixed(1);
        
        div.innerHTML = `
            <span class="num">${Math.floor(i/2) + 1}${i % 2 === 0 ? '.' : '...'}</span>
            <span class="san">${m.san}</span>
            <span class="eval">${evalStr}</span>
            <span class="class class-${m.class}">${classSymbols[m.class]}</span>
        `;
        
        movesEl.appendChild(div);
    });
    
    // –û–±–Ω–æ–≤–∏—Ç—å eval bar
    if (analysisData.length > 0) {
        const lastEval = analysisData[analysisData.length - 1].eval;
        const percentage = Math.max(5, Math.min(95, 50 + lastEval / 20));
        document.getElementById('evalBar').style.width = percentage + '%';
    }
    
    // –ù–∞—Ä–∏—Å–æ–≤–∞—Ç—å –º–∏–Ω–∏-–¥–æ—Å–∫—É
    renderAnalysisBoard();
}

function renderAnalysisBoard() {
    const boardEl = document.getElementById('board2');
    boardEl.innerHTML = '';
    boardEl.className = 'board-' + config.boardColor;
    
    for (let i = 0; i < 64; i++) {
        const r = Math.floor(i / 8);
        const c = i % 8;
        
        const sq = document.createElement('div');
        sq.className = 'sq ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
        sq.style.aspectRatio = '1';
        sq.style.display = 'flex';
        sq.style.alignItems = 'center';
        sq.style.justifyContent = 'center';
        
        if (board[r][c]) {
            const img = document.createElement('img');
            img.src = getPieceUrl(board[r][c]);
            img.style.width = '85%';
            img.style.height = '85%';
            sq.appendChild(img);
        }
        
        boardEl.appendChild(sq);
    }
}
</script>
</body>
</html>
