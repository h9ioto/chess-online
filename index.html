<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–®–∞—Ö–º–∞—Ç—ã</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #262421;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 10px;
            padding-bottom: 60px;
            min-height: 100vh;
        }
        
        .container { max-width: 500px; margin: 0 auto; }
        h1 { color: #fff; text-align: center; font-size: 22px; margin-bottom: 15px; }
        
        .menu { background: #1a1816; border-radius: 12px; padding: 20px; margin-bottom: 15px; display: block; }
        .menu.hidden { display: none; }
        .menu-title { color: #81b64c; font-size: 16px; font-weight: 600; margin-bottom: 15px; text-align: center; }
        
        .setting { margin-bottom: 15px; }
        .setting-label { color: #bababa; font-size: 13px; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .setting-value { color: #81b64c; font-weight: 600; }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #3d3a37;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #81b64c;
            cursor: pointer;
        }
        
        .color-select, .time-select { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; }
        
        .color-btn, .time-btn {
            padding: 10px 12px;
            border: 2px solid #3d3a37;
            border-radius: 8px;
            background: #262421;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .color-btn.active, .time-btn.active { border-color: #81b64c; background: rgba(129,182,76,0.15); }
        .color-btn .piece-icon { font-size: 20px; }
        
        .custom-time {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
            padding: 10px;
            background: #262421;
            border-radius: 8px;
        }
        
        .custom-time.hidden { display: none; }
        .custom-time label { color: #bababa; font-size: 12px; }
        
        .custom-time input {
            width: 50px;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background: #3d3a37;
            color: #fff;
            font-size: 14px;
            text-align: center;
        }
        
        .menu-btns { display: flex; flex-direction: column; gap: 10px; margin-top: 20px; }
        
        .btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: transform 0.1s;
        }
        
        .btn:active { transform: scale(0.97); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.green { background: #81b64c; color: #fff; }
        .btn.blue { background: #4a90d9; color: #fff; }
        .btn.orange { background: #d97f4a; color: #fff; }
        .btn.gray { background: #3d3a37; color: #bababa; }
        .btn.red { background: #c0392b; color: #fff; }
        .btn.yellow { background: #f39c12; color: #fff; }
        .btn.small { padding: 10px 12px; font-size: 12px; }
        
        .online-section { background: #1f1d1b; border-radius: 8px; padding: 15px; margin-top: 15px; }
        .online-title { color: #4a90d9; font-size: 14px; margin-bottom: 10px; }
        
        .game-link { display: flex; gap: 8px; }
        .game-link input {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #3d3a37;
            color: #fff;
            font-size: 14px;
        }
        
        .nick-input {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .nick-input input {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            background: #3d3a37;
            color: #fff;
            font-size: 14px;
        }
        
        .nick-saved {
            color: #81b64c;
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
        }
        
        .waiting { text-align: center; padding: 30px; color: #bababa; }
        .waiting-spinner { font-size: 50px; animation: spin 2s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        
        .game-screen { display: none; }
        .game-screen.active { display: block; }
        .menu-screen { display: block; }
        .menu-screen.hidden { display: none; }
        
        .player-box {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: #1a1816;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .player-box.active { background: #2d2a27; box-shadow: inset 0 0 0 2px #81b64c; }
        
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            background: #4a4745;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .player-info { flex: 1; min-width: 0; }
        .player-name { color: #fff; font-size: 14px; font-weight: 600; }
        .player-rating { color: #7c7a78; font-size: 12px; }
        
        .timer {
            background: #2d2a27;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: bold;
            font-family: monospace;
            min-width: 65px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .timer.low { background: #c0392b; animation: pulse 0.5s infinite; }
        .timer.inactive { background: #1a1816; color: #555; }
        .timer.hidden { display: none; }
        
        @keyframes pulse { 50% { opacity: 0.7; } }
        
        .captured { display: flex; flex-wrap: wrap; gap: 1px; margin-left: 8px; font-size: 14px; }
        
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            aspect-ratio: 1;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            max-width: 480px;
            margin: 0 auto;
        }
        
        .sq {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: min(10vw, 50px);
        }
        
        .sq.w { background: #ebecd0; }
        .sq.b { background: #739552; }
        .sq.sel { background: #f6f669 !important; }
        .sq.lm { background: #f5f682 !important; }
        .sq.ch { background: #eb6a5d !important; }
        .sq.premove-from { background: #e74c3c !important; box-shadow: inset 0 0 0 4px #c0392b; }
        .sq.premove-to { background: #e74c3c !important; box-shadow: inset 0 0 0 4px #a93226; }
        
        .sq.dot::after {
            content: '';
            width: 30%;
            height: 30%;
            background: rgba(0,0,0,0.15);
            border-radius: 50%;
            position: absolute;
        }
        
        .sq.cap::after {
            content: '';
            width: 100%;
            height: 100%;
            border: 5px solid rgba(0,0,0,0.15);
            border-radius: 50%;
            position: absolute;
            box-sizing: border-box;
        }
        
        .sq .piece {
            font-size: inherit;
            line-height: 1;
            pointer-events: none;
            filter: drop-shadow(1px 2px 2px rgba(0,0,0,0.3));
        }
        
        #status {
            text-align: center;
            padding: 12px;
            background: #1a1816;
            border-radius: 8px;
            margin: 10px 0;
            color: #bababa;
            font-size: 15px;
        }
        
        .game-btns { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-top: 10px; }
        
        .history {
            background: #1a1816;
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
            max-height: 80px;
            overflow-y: auto;
        }
        
        .history-title { color: #7c7a78; font-size: 12px; margin-bottom: 8px; }
        
        #movesList {
            display: flex;
            flex-wrap: wrap;
            gap: 3px 8px;
            color: #bababa;
            font-size: 13px;
            font-family: monospace;
        }
        
        .mp { color: #7c7a78; }
        
        .modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); align-items: center; justify-content: center; z-index: 2000; padding: 20px; }
        .modal.show { display: flex; }
        .modal-box { background: #302e2b; border-radius: 12px; padding: 25px; text-align: center; max-width: 400px; width: 100%; max-height: 90vh; overflow-y: auto; }
        .modal-title { color: #fff; font-size: 20px; margin-bottom: 15px; }
        .modal-msg { color: #bababa; margin: 10px 0 20px; font-size: 14px; }
        .promo-opts { display: flex; justify-content: center; gap: 10px; }
        .promo-opt { width: 60px; height: 60px; background: #ebecd0; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 40px; }
        .promo-opt:active { transform: scale(0.95); }
        .modal-icon { font-size: 50px; margin-bottom: 10px; }
        .modal-btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        
        .snd-btn { position: fixed; top: 10px; right: 10px; background: #3d3a37; border: none; color: #fff; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; z-index: 100; }
        
        .online-badge { display: none; align-items: center; gap: 6px; background: #2d4a2d; color: #81b64c; padding: 4px 10px; border-radius: 12px; font-size: 12px; margin-bottom: 10px; }
        .online-badge.show { display: inline-flex; }
        .online-badge .dot { width: 6px; height: 6px; background: #81b64c; border-radius: 50%; }
        
        .copy-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: #81b64c; color: #fff; padding: 12px 24px; border-radius: 25px; font-size: 14px; font-weight: 600; opacity: 0; transition: opacity 0.3s; z-index: 3000; pointer-events: none; }
        .copy-toast.show { opacity: 1; }
        
        .premove-indicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #e74c3c;
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            display: none;
            z-index: 100;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .premove-indicator.show { display: block; }

        .draw-offer {
            background: #f39c12;
            color: #000;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            display: none;
        }
        .draw-offer.show { display: block; }
        .draw-offer-btns { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        
        .conn-status {
            font-size: 11px;
            color: #f39c12;
            text-align: center;
            margin-top: 5px;
        }
        
        /* Analysis styles */
        .analysis-container { margin-top: 15px; }
        
        .analysis-bar {
            height: 24px;
            background: linear-gradient(to right, #fff var(--white-percent, 50%), #333 var(--white-percent, 50%));
            border-radius: 4px;
            position: relative;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .analysis-bar-label {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            font-weight: bold;
        }
        
        .analysis-bar-label.white { left: 8px; color: #333; }
        .analysis-bar-label.black { right: 8px; color: #fff; }
        
        .accuracy-box { display: flex; justify-content: space-around; margin-bottom: 15px; }
        .accuracy-item { text-align: center; }
        .accuracy-value { font-size: 28px; font-weight: bold; color: #81b64c; }
        .accuracy-label { font-size: 12px; color: #bababa; }
        
        .classification-stats { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-bottom: 15px; }
        .class-stat { background: #262421; padding: 5px 10px; border-radius: 4px; font-size: 12px; }
        .class-brilliant { color: #1baca6; }
        .class-great { color: #5c8bb0; }
        .class-best { color: #81b64c; }
        .class-good { color: #81b64c; }
        .class-inaccuracy { color: #f7c631; }
        .class-mistake { color: #e58f2a; }
        .class-blunder { color: #ca3431; }
        
        .moves-analysis { max-height: 200px; overflow-y: auto; text-align: left; }
        
        .move-analysis-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            background: #262421;
            font-size: 13px;
        }
        
        .move-number { color: #7c7a78; width: 30px; }
        .move-notation { flex: 1; color: #fff; }
        .move-eval { color: #bababa; margin-right: 8px; font-size: 11px; }
        .move-class { font-weight: bold; min-width: 20px; text-align: center; }
        
        .analysis-progress { text-align: center; padding: 20px; color: #bababa; }
        .analysis-progress-bar { height: 6px; background: #3d3a37; border-radius: 3px; margin-top: 10px; overflow: hidden; }
        .analysis-progress-fill { height: 100%; background: #81b64c; border-radius: 3px; transition: width 0.3s; }
    </style>
</head>
<body>

<button class="snd-btn" id="sndBtn">üîä</button>
<div class="premove-indicator" id="premoveIndicator">‚ö° –ü—Ä–µ–º—É–≤ (–Ω–∞–∂–º–∏ –¥–ª—è –æ—Ç–º–µ–Ω—ã)</div>

<div class="container">
    <h1>‚ôü –®–∞—Ö–º–∞—Ç—ã</h1>
    
    <div class="menu-screen" id="menuScreen">
        <div class="menu" id="mainMenu">
            <div class="menu-title">üë§ –í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</div>
            <div class="nick-input">
                <input type="text" id="nickInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º..." maxlength="15">
                <button class="btn green small" id="btnSaveNick">üíæ</button>
            </div>
            <div class="nick-saved" id="nickSaved"></div>
            
            <div class="menu-title" style="margin-top:20px;">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
            
            <div class="setting">
                <div class="setting-label">
                    <span>–£—Ä–æ–≤–µ–Ω—å –ò–ò</span>
                    <span class="setting-value" id="eloValue">1400 ELO</span>
                </div>
                <input type="range" id="eloSlider" min="400" max="2800" value="1400" step="200">
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–ö–æ–Ω—Ç—Ä–æ–ª—å –≤—Ä–µ–º–µ–Ω–∏</span></div>
                <div class="time-select" id="timeSelect">
                    <button class="time-btn" data-time="1|0">1+0</button>
                    <button class="time-btn" data-time="3|0">3+0</button>
                    <button class="time-btn" data-time="3|2">3+2</button>
                    <button class="time-btn" data-time="5|0">5+0</button>
                    <button class="time-btn" data-time="5|5">5+5</button>
                    <button class="time-btn active" data-time="10|0">10+0</button>
                    <button class="time-btn" data-time="15|10">15+10</button>
                    <button class="time-btn" data-time="0|0">‚àû</button>
                    <button class="time-btn" data-time="custom">‚öôÔ∏è</button>
                </div>
                <div class="custom-time hidden" id="customTime">
                    <label>–ú–∏–Ω:</label>
                    <input type="number" id="customMins" value="10" min="1" max="180">
                    <label>+–°–µ–∫:</label>
                    <input type="number" id="customSecs" value="0" min="0" max="60">
                </div>
            </div>
            
            <div class="setting">
                <div class="setting-label"><span>–í–∞—à —Ü–≤–µ—Ç</span></div>
                <div class="color-select" id="colorSelect">
                    <button class="color-btn active" data-color="white">
                        <span class="piece-icon">‚ôî</span> –ë–µ–ª—ã–µ
                    </button>
                    <button class="color-btn" data-color="random">üé≤</button>
                    <button class="color-btn" data-color="black">
                        <span class="piece-icon">‚ôö</span> –ß—ë—Ä–Ω—ã–µ
                    </button>
                </div>
            </div>
            
            <div class="menu-btns">
                <button class="btn green" id="btnPlayAI">ü§ñ –ò–≥—Ä–∞—Ç—å —Å –ò–ò</button>
            </div>
            
            <div class="online-section">
                <div class="online-title">üåê –ò–≥—Ä–∞—Ç—å —Å –¥—Ä—É–≥–æ–º</div>
                <div class="menu-btns" style="margin-top:10px;">
                    <button class="btn blue" id="btnCreateGame">‚ûï –°–æ–∑–¥–∞—Ç—å –∏–≥—Ä—É</button>
                </div>
                <div class="game-link" style="margin-top:12px;">
                    <input type="text" id="joinCode" placeholder="–ö–æ–¥ –∏–≥—Ä—ã (5 —Å–∏–º–≤–æ–ª–æ–≤)..." maxlength="5">
                    <button class="btn orange" id="btnJoinGame">‚Üí</button>
                </div>
                <div class="conn-status" id="connStatus"></div>
            </div>
        </div>
        
        <div class="menu hidden" id="waitingRoom">
            <div class="waiting">
                <div class="waiting-spinner">‚ôü</div>
                <p style="margin-top:15px;font-size:16px;">–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...</p>
                <p style="margin-top:10px;color:#81b64c;font-size:24px;font-weight:bold;letter-spacing:3px;" id="gameCodeDisplay"></p>
                <p style="margin-top:5px;color:#7c7a78;font-size:12px;">–û—Ç–ø—Ä–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –∫–æ–¥ –¥—Ä—É–≥—É</p>
            </div>
            <div class="game-link" style="margin-top:20px;">
                <input type="text" id="shareLink" readonly style="font-size:11px;">
                <button class="btn gray" id="btnCopyLink">üìã</button>
            </div>
            <button class="btn gray" style="margin-top:12px;width:100%;" id="btnCancelWait">‚úï –û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
    
    <div class="game-screen" id="gameScreen">
        <div id="onlineBadge" class="online-badge">
            <span class="dot"></span>
            <span id="opponentNickBadge">–û–Ω–ª–∞–π–Ω</span>
        </div>
        
        <div class="player-box" id="topPlayer">
            <div class="avatar" id="topAvatar">ü§ñ</div>
            <div class="player-info">
                <div class="player-name" id="topName">–ë–æ—Ç</div>
                <div class="player-rating" id="topRating">1400 ELO</div>
            </div>
            <div class="captured" id="topCaptured"></div>
            <div class="timer inactive" id="topTimer">10:00</div>
        </div>
        
        <div id="board"></div>
        
        <div class="player-box active" id="bottomPlayer">
            <div class="avatar" id="bottomAvatar">üë§</div>
            <div class="player-info">
                <div class="player-name" id="bottomName">–í—ã</div>
                <div class="player-rating" id="bottomRating">–ë–µ–ª—ã–µ</div>
            </div>
            <div class="captured" id="bottomCaptured"></div>
            <div class="timer" id="bottomTimer">10:00</div>
        </div>
        
        <div class="draw-offer" id="drawOffer">
            <span>ü§ù –°–æ–ø–µ—Ä–Ω–∏–∫ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –Ω–∏—á—å—é</span>
            <div class="draw-offer-btns">
                <button class="btn green small" id="btnAcceptDraw">‚úì –ü—Ä–∏–Ω—è—Ç—å</button>
                <button class="btn red small" id="btnDeclineDraw">‚úï –û—Ç–∫–ª–æ–Ω–∏—Ç—å</button>
            </div>
        </div>
        
        <div id="status">–í–∞—à —Ö–æ–¥</div>
        
        <div class="game-btns">
            <button class="btn gray small" id="btnBackMenu">üè†</button>
            <button class="btn gray small" id="btnUndo">‚Ü©Ô∏è</button>
            <button class="btn yellow small" id="btnDraw">ü§ù</button>
            <button class="btn red small" id="btnResign">üè≥Ô∏è</button>
            <button class="btn blue small" id="btnAnalyze">üìä</button>
        </div>
        
        <div class="history">
            <div class="history-title">–ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤</div>
            <div id="movesList"></div>
        </div>
    </div>
</div>

<div class="modal" id="promoModal">
    <div class="modal-box">
        <div class="modal-title">–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ</div>
        <div class="promo-opts" id="promoOpts"></div>
    </div>
</div>

<div class="modal" id="endModal">
    <div class="modal-box">
        <div class="modal-icon" id="endIcon">üèÜ</div>
        <div class="modal-title" id="endTitle">–ü–æ–±–µ–¥–∞!</div>
        <div class="modal-msg" id="endMsg"></div>
        <div class="modal-btns">
            <button class="btn blue" id="btnAnalyzeEnd">üìä –ê–Ω–∞–ª–∏–∑</button>
            <button class="btn green" id="btnRematch">üîÑ –†–µ–≤–∞–Ω—à</button>
            <button class="btn gray" id="btnEndMenu">üè† –ú–µ–Ω—é</button>
        </div>
    </div>
</div>

<div class="modal" id="confirmModal">
    <div class="modal-box">
        <div class="modal-title" id="confirmTitle">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</div>
        <div class="modal-msg" id="confirmMsg"></div>
        <div class="modal-btns">
            <button class="btn green" id="confirmYes">–î–∞</button>
            <button class="btn gray" id="confirmNo">–û—Ç–º–µ–Ω–∞</button>
        </div>
    </div>
</div>

<div class="modal" id="analysisModal">
    <div class="modal-box" style="max-width:450px;">
        <div class="modal-title">üìä –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏</div>
        <div id="analysisContent">
            <div class="analysis-progress">
                <div>–ê–Ω–∞–ª–∏–∑...</div>
                <div id="analysisProgressText">0 / 0</div>
                <div class="analysis-progress-bar">
                    <div class="analysis-progress-fill" id="analysisProgressBar" style="width:0%"></div>
                </div>
            </div>
        </div>
        <div class="modal-btns" style="margin-top:15px;">
            <button class="btn gray" id="btnCloseAnalysis">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>
</div>

<div class="copy-toast" id="copyToast">‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</div>

<audio id="sndMove" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-self.mp3"></audio>
<audio id="sndCapture" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/capture.mp3"></audio>
<audio id="sndCheck" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-check.mp3"></audio>
<audio id="sndCastle" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/castle.mp3"></audio>
<audio id="sndPromo" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/promote.mp3"></audio>
<audio id="sndEnd" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/game-end.mp3"></audio>
<audio id="sndPremove" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/premove.mp3"></audio>
<audio id="sndIllegal" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/illegal.mp3"></audio>
<audio id="sndLowTime" preload="auto" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/tenseconds.mp3"></audio>

<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script>
// ========== –ö–û–ù–°–¢–ê–ù–¢–´ ==========
// Unicode —Å–∏–º–≤–æ–ª—ã –¥–ª—è —Ñ–∏–≥—É—Ä (—Ä–∞–±–æ—Ç–∞—é—Ç –≤–µ–∑–¥–µ)
const PIECES = {
    K: '‚ôî', Q: '‚ôï', R: '‚ôñ', B: '‚ôó', N: '‚ôò', P: '‚ôô',
    k: '‚ôö', q: '‚ôõ', r: '‚ôú', b: '‚ôù', n: '‚ôû', p: '‚ôü'
};
const VAL = {p:100,n:320,b:330,r:500,q:900,k:20000};

// ========== –°–û–°–¢–û–Ø–ù–ò–ï ==========
let settings = {elo:1400, color:'white', time:'10|0'};
let soundOn = true;
let brd, turn, sel, moves, lastMv, over, aiGo, hist, notation, capW, capB, ep, castle;
let playerColor = true, flipped = false, premove = null;
let whiteTime = 600, blackTime = 600, increment = 0, timerInterval = null;
let lowTimeWarned = {w:false, b:false};
let isOnline = false, gameCode = null, myColor = 'white', opponentNick = '–°–æ–ø–µ—Ä–Ω–∏–∫';
let myNick = localStorage.getItem('chessNick') || '';
let peer = null, conn = null, isHost = false;
let gameHistory = [];
let stockfish = null;

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM –∑–∞–≥—Ä—É–∂–µ–Ω');
    
    if (myNick) {
        document.getElementById('nickInput').value = myNick;
        document.getElementById('nickSaved').textContent = '‚úì –ü—Ä–∏–≤–µ—Ç, ' + myNick + '!';
    }
    
    document.getElementById('eloSlider').addEventListener('input', function() {
        settings.elo = parseInt(this.value);
        document.getElementById('eloValue').textContent = settings.elo + ' ELO';
    });
    
    document.getElementById('btnSaveNick').addEventListener('click', saveNick);
    document.getElementById('nickInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') saveNick();
    });
    
    document.getElementById('timeSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.time-btn');
        if (!btn) return;
        document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const time = btn.dataset.time;
        if (time === 'custom') {
            document.getElementById('customTime').classList.remove('hidden');
        } else {
            document.getElementById('customTime').classList.add('hidden');
            settings.time = time;
        }
    });
    
    document.getElementById('colorSelect').addEventListener('click', function(e) {
        const btn = e.target.closest('.color-btn');
        if (!btn) return;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        settings.color = btn.dataset.color;
    });
    
    document.getElementById('btnPlayAI').addEventListener('click', startVsAI);
    document.getElementById('btnCreateGame').addEventListener('click', createGame);
    document.getElementById('btnJoinGame').addEventListener('click', joinGame);
    document.getElementById('btnCopyLink').addEventListener('click', copyLink);
    document.getElementById('btnCancelWait').addEventListener('click', cancelWaiting);
    
    document.getElementById('joinCode').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') joinGame();
    });
    document.getElementById('joinCode').addEventListener('input', function() {
        this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
    });
    
    document.getElementById('btnBackMenu').addEventListener('click', backToMenu);
    document.getElementById('btnUndo').addEventListener('click', undoMove);
    document.getElementById('btnDraw').addEventListener('click', offerDraw);
    document.getElementById('btnResign').addEventListener('click', resign);
    document.getElementById('btnAnalyze').addEventListener('click', startAnalysis);
    document.getElementById('btnAcceptDraw').addEventListener('click', acceptDraw);
    document.getElementById('btnDeclineDraw').addEventListener('click', declineDraw);
    
    document.getElementById('btnRematch').addEventListener('click', rematch);
    document.getElementById('btnEndMenu').addEventListener('click', backToMenu);
    document.getElementById('btnAnalyzeEnd').addEventListener('click', function() {
        document.getElementById('endModal').classList.remove('show');
        startAnalysis();
    });
    document.getElementById('confirmNo').addEventListener('click', closeConfirm);
    document.getElementById('btnCloseAnalysis').addEventListener('click', function() {
        document.getElementById('analysisModal').classList.remove('show');
    });
    
    document.getElementById('sndBtn').addEventListener('click', toggleSound);
    document.getElementById('premoveIndicator').addEventListener('click', clearPremove);
    
    checkUrlForGame();
    initStockfish();
    
    console.log('–í—Å–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã');
});

// ========== –ù–ò–ö–ù–ï–ô–ú ==========
function saveNick() {
    const nick = document.getElementById('nickInput').value.trim();
    if (!nick) {
        alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º!');
        return;
    }
    myNick = nick;
    localStorage.setItem('chessNick', nick);
    document.getElementById('nickSaved').textContent = '‚úì –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ! –ü—Ä–∏–≤–µ—Ç, ' + nick + '!';
}

// ========== –ó–í–£–ö–ò ==========
function playSound(id) {
    if (!soundOn) return;
    const audio = document.getElementById(id);
    if (audio) { audio.currentTime = 0; audio.play().catch(() => {}); }
}

function toggleSound() {
    soundOn = !soundOn;
    document.getElementById('sndBtn').textContent = soundOn ? 'üîä' : 'üîá';
}

// ========== –í–†–ï–ú–Ø ==========
function getTimeSettings() {
    const activeBtn = document.querySelector('.time-btn.active');
    if (activeBtn && activeBtn.dataset.time === 'custom') {
        const mins = parseInt(document.getElementById('customMins').value) || 10;
        const secs = parseInt(document.getElementById('customSecs').value) || 0;
        return { time: mins * 60, inc: secs };
    }
    const [mins, inc] = settings.time.split('|').map(Number);
    return { time: mins * 60, inc: inc };
}

function formatTime(seconds) {
    if (seconds <= 0) return '0:00';
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return m + ':' + (s < 10 ? '0' : '') + s;
}

function startTimer() {
    const ts = getTimeSettings();
    if (ts.time === 0) return;
    stopTimer();
    timerInterval = setInterval(function() {
        if (over || aiGo) return;
        if (turn === 'w') {
            whiteTime -= 0.1;
            if (whiteTime <= 10 && !lowTimeWarned.w) { playSound('sndLowTime'); lowTimeWarned.w = true; }
            if (whiteTime <= 0) { whiteTime = 0; timeOut('white'); }
        } else {
            blackTime -= 0.1;
            if (blackTime <= 10 && !lowTimeWarned.b) { playSound('sndLowTime'); lowTimeWarned.b = true; }
            if (blackTime <= 0) { blackTime = 0; timeOut('black'); }
        }
        updateTimerDisplay();
    }, 100);
}

function stopTimer() {
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
}

function addIncrement(isWhite) {
    if (isWhite) whiteTime += increment;
    else blackTime += increment;
}

function updateTimerDisplay() {
    const ts = getTimeSettings();
    const topTimer = document.getElementById('topTimer');
    const bottomTimer = document.getElementById('bottomTimer');
    
    if (ts.time === 0) {
        topTimer.classList.add('hidden');
        bottomTimer.classList.add('hidden');
        return;
    }
    
    topTimer.classList.remove('hidden');
    bottomTimer.classList.remove('hidden');
    
    const topIsBlack = playerColor;
    const topTime = topIsBlack ? blackTime : whiteTime;
    const bottomTime = topIsBlack ? whiteTime : blackTime;
    
    topTimer.textContent = formatTime(topTime);
    bottomTimer.textContent = formatTime(bottomTime);
    
    const isWhiteTurn = turn === 'w';
    const topActive = topIsBlack ? !isWhiteTurn : isWhiteTurn;
    
    topTimer.classList.toggle('inactive', !topActive || over);
    bottomTimer.classList.toggle('inactive', topActive || over);
    topTimer.classList.toggle('low', topTime <= 30 && topActive && !over);
    bottomTimer.classList.toggle('low', bottomTime <= 30 && !topActive && !over);
}

function timeOut(color) {
    over = true;
    stopTimer();
    const playerLost = (color === 'white') === playerColor;
    showEnd(playerLost ? 'lose' : 'win', '–í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ');
}

// ========== –ú–£–õ–¨–¢–ò–ü–õ–ï–ï–† (PeerJS) ==========
function genCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
    return code;
}

function createGame() {
    if (!myNick) {
        alert('–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º!');
        document.getElementById('nickInput').focus();
        return;
    }
    
    gameCode = genCode();
    isHost = true;
    myColor = settings.color === 'random' ? (Math.random() < 0.5 ? 'white' : 'black') : settings.color;
    
    document.getElementById('gameCodeDisplay').textContent = gameCode;
    document.getElementById('shareLink').value = location.href.split('?')[0] + '?g=' + gameCode;
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('waitingRoom').classList.remove('hidden');
    
    initPeer(gameCode, true);
}

function joinGame() {
    const code = document.getElementById('joinCode').value.trim().toUpperCase();
    if (!code || code.length < 5) {
        alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –∏–∑ 5 —Å–∏–º–≤–æ–ª–æ–≤!');
        return;
    }
    
    if (!myNick) {
        alert('–°–Ω–∞—á–∞–ª–∞ –≤–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º!');
        document.getElementById('nickInput').focus();
        return;
    }
    
    gameCode = code;
    isHost = false;
    document.getElementById('connStatus').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...';
    document.getElementById('btnJoinGame').disabled = true;
    
    initPeer(null, false);
}

function initPeer(hostId, hosting) {
    console.log('initPeer', hostId, hosting);
    
    if (peer) {
        peer.destroy();
        peer = null;
    }
    
    const peerId = hosting ? 'chess-' + hostId : 'chess-guest-' + genCode();
    
    peer = new Peer(peerId, {
        debug: 1,
        config: {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478' },
                { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                { urls: 'turn:openrelay.metered.ca:443?transport=tcp', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        }
    });
    
    peer.on('open', function(id) {
        console.log('Peer –æ—Ç–∫—Ä—ã—Ç:', id);
        
        if (!hosting) {
            console.log('–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫:', 'chess-' + gameCode);
            
            setTimeout(function() {
                conn = peer.connect('chess-' + gameCode, { reliable: true });
                
                conn.on('open', function() {
                    console.log('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ!');
                    document.getElementById('connStatus').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ!';
                    document.getElementById('btnJoinGame').disabled = false;
                    conn.send({ type: 'join', nick: myNick });
                });
                
                conn.on('data', handleData);
                
                conn.on('close', function() {
                    console.log('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ');
                    if (isOnline && !over) {
                        document.getElementById('status').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è';
                    }
                });
                
                conn.on('error', function(err) {
                    console.error('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:', err);
                    document.getElementById('connStatus').textContent = '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
                    document.getElementById('btnJoinGame').disabled = false;
                });
            }, 500);
            
            setTimeout(function() {
                if (!conn || !conn.open) {
                    document.getElementById('connStatus').textContent = '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ–¥.';
                    document.getElementById('btnJoinGame').disabled = false;
                    if (peer) { peer.destroy(); peer = null; }
                }
            }, 15000);
        }
    });
    
    peer.on('connection', function(connection) {
        console.log('–í—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ!');
        conn = connection;
        
        conn.on('open', function() {
            console.log('–ì–æ—Å—Ç—å –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è');
        });
        
        conn.on('data', handleData);
        
        conn.on('close', function() {
            console.log('–ì–æ—Å—Ç—å –æ—Ç–∫–ª—é—á–∏–ª—Å—è');
            if (isOnline && !over) {
                document.getElementById('status').textContent = '–°–æ–ø–µ—Ä–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è';
            }
        });
    });
    
    peer.on('error', function(err) {
        console.error('–û—à–∏–±–∫–∞ Peer:', err);
        
        if (err.type === 'unavailable-id') {
            if (isHost) {
                gameCode = genCode();
                document.getElementById('gameCodeDisplay').textContent = gameCode;
                document.getElementById('shareLink').value = location.href.split('?')[0] + '?g=' + gameCode;
                setTimeout(function() { initPeer(gameCode, true); }, 1000);
            }
        } else if (err.type === 'peer-unavailable') {
            document.getElementById('connStatus').textContent = '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ö–æ—Å—Ç –æ–Ω–ª–∞–π–Ω.';
            document.getElementById('btnJoinGame').disabled = false;
        } else if (err.type === 'network' || err.type === 'server-error') {
            document.getElementById('connStatus').textContent = '–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
            document.getElementById('btnJoinGame').disabled = false;
        }
    });
    
    peer.on('disconnected', function() {
        console.log('Peer –æ—Ç–∫–ª—é—á–µ–Ω');
    });
}

function handleData(data) {
    console.log('–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ:', data);
    
    if (data.type === 'join') {
        opponentNick = data.nick || '–°–æ–ø–µ—Ä–Ω–∏–∫';
        conn.send({
            type: 'start',
            nick: myNick,
            hostColor: myColor,
            time: settings.time
        });
        startOnlineGame();
    }
    
    if (data.type === 'start') {
        opponentNick = data.nick || '–°–æ–ø–µ—Ä–Ω–∏–∫';
        myColor = data.hostColor === 'white' ? 'black' : 'white';
        settings.time = data.time;
        startOnlineGame();
    }
    
    if (data.type === 'move') {
        const mv = data.mv;
        doMove(mv, mv.promo || 'q');
        playMoveSound(mv);
        addIncrement(turn === 'b');
        aiGo = false;
        updUI(); draw(); checkEnd();
        if (premove && !over) setTimeout(executePremove, 100);
    }
    
    if (data.type === 'resign') {
        over = true; stopTimer();
        showEnd('win', opponentNick + ' —Å–¥–∞–ª—Å—è');
    }
    
    if (data.type === 'draw-offer') {
        document.getElementById('drawOffer').classList.add('show');
        playSound('sndMove');
    }
    
    if (data.type === 'draw-accept') {
        over = true; stopTimer();
        showEnd('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
        document.getElementById('drawOffer').classList.remove('show');
    }
    
    if (data.type === 'draw-decline') {
        document.getElementById('status').textContent = '–ù–∏—á—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞';
        document.getElementById('drawOffer').classList.remove('show');
        setTimeout(function() { if (!over) updUI(); }, 2000);
    }
}

function startOnlineGame() {
    console.log('–°—Ç–∞—Ä—Ç –æ–Ω–ª–∞–π–Ω –∏–≥—Ä—ã, –º–æ–π —Ü–≤–µ—Ç:', myColor);
    isOnline = true;
    playerColor = myColor === 'white';
    flipped = !playerColor;
    
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('mainMenu').classList.add('hidden');
    document.getElementById('connStatus').textContent = '';
    
    initGame();
    
    document.getElementById('topName').textContent = opponentNick;
    document.getElementById('topAvatar').textContent = 'üë§';
    document.getElementById('topRating').textContent = myColor === 'white' ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
    document.getElementById('bottomName').textContent = myNick || '–í—ã';
    document.getElementById('bottomRating').textContent = myColor === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.add('show');
    document.getElementById('opponentNickBadge').textContent = opponentNick;
    
    showGame();
    startTimer();
}

function cancelWaiting() {
    document.getElementById('waitingRoom').classList.add('hidden');
    document.getElementById('mainMenu').classList.remove('hidden');
    if (peer) { peer.destroy(); peer = null; }
    conn = null;
    gameCode = null;
}

function copyLink() {
    const link = document.getElementById('shareLink').value;
    navigator.clipboard.writeText(link).catch(function() {
        document.getElementById('shareLink').select();
        document.execCommand('copy');
    });
    document.getElementById('copyToast').classList.add('show');
    setTimeout(function() { document.getElementById('copyToast').classList.remove('show'); }, 2000);
}

function checkUrlForGame() {
    const params = new URLSearchParams(window.location.search);
    const g = params.get('g');
    if (g) {
        document.getElementById('joinCode').value = g.toUpperCase();
    }
}

function sendData(data) {
    if (conn && conn.open) {
        conn.send(data);
    }
}

// ========== –ò–ì–†–ê ==========
function initGame() {
    brd = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    turn = 'w'; sel = null; moves = []; lastMv = null; over = false; aiGo = false;
    hist = []; notation = []; capW = []; capB = []; ep = null;
    castle = { K: 1, Q: 1, k: 1, q: 1 };
    clearPremove();
    lowTimeWarned = {w: false, b: false};
    
    const ts = getTimeSettings();
    whiteTime = ts.time; blackTime = ts.time; increment = ts.inc;
    
    gameHistory = [getFEN()];
    
    document.getElementById('drawOffer').classList.remove('show');
    document.getElementById('endModal').classList.remove('show');
    document.getElementById('promoModal').classList.remove('show');
    updateTimerDisplay();
}

function startVsAI() {
    console.log('–ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã —Å –ò–ò');
    isOnline = false;
    playerColor = settings.color === 'random' ? Math.random() < 0.5 : settings.color === 'white';
    flipped = !playerColor;
    
    initGame();
    
    document.getElementById('topName').textContent = '–ë–æ—Ç';
    document.getElementById('topAvatar').textContent = 'ü§ñ';
    document.getElementById('topRating').textContent = settings.elo + ' ELO';
    document.getElementById('bottomName').textContent = myNick || '–í—ã';
    document.getElementById('bottomRating').textContent = playerColor ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ';
    document.getElementById('onlineBadge').classList.remove('show');
    
    showGame();
    startTimer();
    
    if (!playerColor) {
        aiGo = true;
        updUI();
        setTimeout(aiMove, 400);
    }
}

function showGame() {
    document.getElementById('menuScreen').classList.add('hidden');
    document.getElementById('gameScreen').classList.add('active');
    updUI(); draw();
}

function backToMenu() {
    stopTimer();
    document.getElementById('menuScreen').classList.remove('hidden');
    document.getElementById('gameScreen').classList.remove('active');
    document.getElementById('endModal').classList.remove('show');
    document.getElementById('analysisModal').classList.remove('show');
    document.getElementById('mainMenu').classList.remove('hidden');
    document.getElementById('waitingRoom').classList.add('hidden');
    if (peer) { peer.destroy(); peer = null; }
    conn = null;
    isOnline = false;
    clearPremove();
}

function rematch() {
    document.getElementById('endModal').classList.remove('show');
    if (isOnline) {
        initGame();
        updUI(); draw();
        startTimer();
    } else {
        startVsAI();
    }
}

// ========== –ü–†–ï–ú–£–í ==========
function clearPremove() {
    premove = null;
    sel = null;
    moves = [];
    document.getElementById('premoveIndicator').classList.remove('show');
}

function setPremove(fromR, fromC, toR, toC) {
    premove = { from: { r: fromR, c: fromC }, to: { r: toR, c: toC } };
    playSound('sndPremove');
    document.getElementById('premoveIndicator').classList.add('show');
    sel = null; moves = [];
    draw();
}

function executePremove() {
    if (!premove) return;
    const pm = premove;
    clearPremove();
    
    const piece = brd[pm.from.r][pm.from.c];
    if (!piece || isW(piece) !== playerColor) {
        playSound('sndIllegal');
        draw();
        return;
    }
    
    const legalMoves = getMoves(pm.from.r, pm.from.c);
    const validMove = legalMoves.find(m => m.tr === pm.to.r && m.tc === pm.to.c);
    
    if (validMove) {
        execMove(validMove, validMove.pro ? 'q' : undefined);
    } else {
        playSound('sndIllegal');
        draw();
    }
}

// ========== –°–î–ê–¢–¨–°–Ø / –ù–ò–ß–¨–Ø ==========
function resign() {
    if (over) return;
    showConfirm('–°–¥–∞—Ç—å—Å—è?', '–í—ã —É–≤–µ—Ä–µ–Ω—ã?', function() {
        over = true; stopTimer();
        if (isOnline) sendData({ type: 'resign' });
        showEnd('lose', '–í—ã —Å–¥–∞–ª–∏—Å—å');
    });
}

function offerDraw() {
    if (over) return;
    if (isOnline) {
        sendData({ type: 'draw-offer' });
        document.getElementById('status').textContent = '–ù–∏—á—å—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∞...';
    } else {
        const ev = evaluate();
        const aiAdvantage = playerColor ? ev < -100 : ev > 100;
        if (aiAdvantage) {
            document.getElementById('status').textContent = '–ò–ò –æ—Ç–∫–ª–æ–Ω–∏–ª –Ω–∏—á—å—é';
            setTimeout(function() { if (!over) updUI(); }, 2000);
        } else {
            over = true; stopTimer();
            showEnd('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
        }
    }
}

function acceptDraw() {
    document.getElementById('drawOffer').classList.remove('show');
    over = true; stopTimer();
    sendData({ type: 'draw-accept' });
    showEnd('draw', '–ù–∏—á—å—è –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é');
}

function declineDraw() {
    document.getElementById('drawOffer').classList.remove('show');
    sendData({ type: 'draw-decline' });
    document.getElementById('status').textContent = '–ù–∏—á—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞';
    setTimeout(function() { if (!over) updUI(); }, 2000);
}

function showConfirm(title, msg, onYes) {
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMsg').textContent = msg;
    document.getElementById('confirmYes').onclick = function() { closeConfirm(); onYes(); };
    document.getElementById('confirmModal').classList.add('show');
}

function closeConfirm() {
    document.getElementById('confirmModal').classList.remove('show');
}

// ========== –õ–û–ì–ò–ö–ê ==========
function isW(p) { return p && p === p.toUpperCase(); }
function isB(p) { return p && p === p.toLowerCase(); }

function getMoves(r, c, legal) {
    if (legal === undefined) legal = true;
    const p = brd[r][c]; if (!p) return [];
    const w = isW(p), t = p.toLowerCase(); let m = [];
    
    if (t === 'p') {
        const d = w ? -1 : 1, start = w ? 6 : 1, promo = w ? 0 : 7;
        if (brd[r+d] && !brd[r+d][c]) {
            m.push({ fr:r, fc:c, tr:r+d, tc:c, pro: r+d===promo });
            if (r === start && !brd[r+2*d][c]) m.push({ fr:r, fc:c, tr:r+2*d, tc:c, dbl:1 });
        }
        [-1, 1].forEach(function(dc) {
            const nc = c + dc; if (nc < 0 || nc > 7) return;
            if (brd[r+d] && brd[r+d][nc] && (w ? isB(brd[r+d][nc]) : isW(brd[r+d][nc])))
                m.push({ fr:r, fc:c, tr:r+d, tc:nc, pro: r+d===promo });
            if (ep && ep.r === r+d && ep.c === nc) m.push({ fr:r, fc:c, tr:r+d, tc:nc, isEp:1 });
        });
    }
    
    if (t === 'n') {
        [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(function(o) {
            const nr = r+o[0], nc = c+o[1];
            if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!brd[nr][nc] || (w ? isB(brd[nr][nc]) : isW(brd[nr][nc]))))
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
        });
    }
    
    if (t === 'b' || t === 'q') {
        [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(function(o) {
            let nr = r+o[0], nc = c+o[1];
            while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                if (brd[nr][nc] && (w ? isW(brd[nr][nc]) : isB(brd[nr][nc]))) break;
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
                if (brd[nr][nc]) break; nr += o[0]; nc += o[1];
            }
        });
    }
    
    if (t === 'r' || t === 'q') {
        [[-1,0],[1,0],[0,-1],[0,1]].forEach(function(o) {
            let nr = r+o[0], nc = c+o[1];
            while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                if (brd[nr][nc] && (w ? isW(brd[nr][nc]) : isB(brd[nr][nc]))) break;
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
                if (brd[nr][nc]) break; nr += o[0]; nc += o[1];
            }
        });
    }
    
    if (t === 'k') {
        for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++) {
            if (!dr && !dc) continue;
            const nr = r+dr, nc = c+dc;
            if (nr>=0 && nr<8 && nc>=0 && nc<8 && (!brd[nr][nc] || (w ? isB(brd[nr][nc]) : isW(brd[nr][nc]))))
                m.push({ fr:r, fc:c, tr:nr, tc:nc });
        }
        if (legal && !inCheck(w)) {
            const row = w ? 7 : 0;
            if (castle[w ? 'K' : 'k'] && !brd[row][5] && !brd[row][6] && brd[row][7] && brd[row][7].toLowerCase()==='r')
                if (!attacked(row,5,!w) && !attacked(row,6,!w)) m.push({ fr:row, fc:4, tr:row, tc:6, cst:'k' });
            if (castle[w ? 'Q' : 'q'] && !brd[row][1] && !brd[row][2] && !brd[row][3] && brd[row][0] && brd[row][0].toLowerCase()==='r')
                if (!attacked(row,2,!w) && !attacked(row,3,!w)) m.push({ fr:row, fc:4, tr:row, tc:2, cst:'q' });
        }
    }
    
    if (legal) m = m.filter(mv => isLegal(mv, w));
    return m;
}

function isLegal(mv, w) {
    const pc = brd[mv.fr][mv.fc], cap = brd[mv.tr][mv.tc];
    brd[mv.tr][mv.tc] = pc; brd[mv.fr][mv.fc] = '';
    let epCap = null;
    if (mv.isEp) { const er = w ? mv.tr+1 : mv.tr-1; epCap = brd[er][mv.tc]; brd[er][mv.tc] = ''; }
    const ok = !inCheck(w);
    brd[mv.fr][mv.fc] = pc; brd[mv.tr][mv.tc] = cap;
    if (epCap !== null) brd[w ? mv.tr+1 : mv.tr-1][mv.tc] = epCap;
    return ok;
}

function findKing(w) {
    const k = w ? 'K' : 'k';
    for (let r=0; r<8; r++) for (let c=0; c<8; c++) if (brd[r][c]===k) return {r,c};
    return null;
}

function attacked(r, c, byW) {
    for (let i=0; i<8; i++) for (let j=0; j<8; j++) {
        const p = brd[i][j];
        if (p && isW(p)===byW) {
            const mvs = getMoves(i, j, false);
            for (let k=0; k<mvs.length; k++) if (mvs[k].tr===r && mvs[k].tc===c) return true;
        }
    }
    return false;
}

function inCheck(w) { const k = findKing(w); return k && attacked(k.r, k.c, !w); }

function allMoves(w) {
    let a = [];
    for (let r=0; r<8; r++) for (let c=0; c<8; c++)
        if (brd[r][c] && isW(brd[r][c])===w) a = a.concat(getMoves(r,c));
    return a;
}

function getFEN() {
    let fen = '';
    for (let r = 0; r < 8; r++) {
        let empty = 0;
        for (let c = 0; c < 8; c++) {
            if (brd[r][c]) {
                if (empty > 0) { fen += empty; empty = 0; }
                fen += brd[r][c];
            } else {
                empty++;
            }
        }
        if (empty > 0) fen += empty;
        if (r < 7) fen += '/';
    }
    fen += ' ' + turn;
    let castleStr = '';
    if (castle.K) castleStr += 'K';
    if (castle.Q) castleStr += 'Q';
    if (castle.k) castleStr += 'k';
    if (castle.q) castleStr += 'q';
    fen += ' ' + (castleStr || '-');
    fen += ' ' + (ep ? 'abcdefgh'[ep.c] + (8 - ep.r) : '-');
    fen += ' 0 1';
    return fen;
}

function doMove(mv, promo) {
    if (!promo) promo = 'q';
    const pc = brd[mv.fr][mv.fc], w = isW(pc), cap = brd[mv.tr][mv.tc];
    hist.push({ mv:{fr:mv.fr,fc:mv.fc,tr:mv.tr,tc:mv.tc,cst:mv.cst,pro:mv.pro,isEp:mv.isEp,dbl:mv.dbl}, pc, cap, ep:ep?{r:ep.r,c:ep.c}:null, castle:{...castle}, epCap:null, capW:capW.slice(), capB:capB.slice() });
    
    let captured = cap;
    if (mv.isEp) { const er = w ? mv.tr+1 : mv.tr-1; captured = brd[er][mv.tc]; hist[hist.length-1].epCap = captured; brd[er][mv.tc] = ''; }
    if (captured) (w ? capW : capB).push(captured);
    
    brd[mv.tr][mv.tc] = pc; brd[mv.fr][mv.fc] = '';
    
    if (mv.cst) {
        const row = mv.tr;
        if (mv.cst === 'k') { brd[row][5] = brd[row][7]; brd[row][7] = ''; }
        else { brd[row][3] = brd[row][0]; brd[row][0] = ''; }
    }
    if (mv.pro) brd[mv.tr][mv.tc] = w ? promo.toUpperCase() : promo.toLowerCase();
    
    if (pc === 'K') { castle.K = 0; castle.Q = 0; }
    if (pc === 'k') { castle.k = 0; castle.q = 0; }
    if (mv.fr===7 && mv.fc===7) castle.K = 0;
    if (mv.fr===7 && mv.fc===0) castle.Q = 0;
    if (mv.fr===0 && mv.fc===7) castle.k = 0;
    if (mv.fr===0 && mv.fc===0) castle.q = 0;
    if (mv.tr===7 && mv.tc===7) castle.K = 0;
    if (mv.tr===7 && mv.tc===0) castle.Q = 0;
    if (mv.tr===0 && mv.tc===7) castle.k = 0;
    if (mv.tr===0 && mv.tc===0) castle.q = 0;
    
    ep = mv.dbl ? { r: (mv.fr+mv.tr)/2, c: mv.fc } : null;
    
    const files = 'abcdefgh', ranks = '87654321';
    let n = mv.cst === 'k' ? 'O-O' : mv.cst === 'q' ? 'O-O-O' : '';
    if (!n) {
        if (pc.toUpperCase() !== 'P') n += pc.toUpperCase();
        if (captured) { if (pc.toUpperCase() === 'P') n += files[mv.fc]; n += 'x'; }
        n += files[mv.tc] + ranks[mv.tr];
        if (mv.pro) n += '=' + promo.toUpperCase();
    }
    notation.push(n);
    
    lastMv = mv; turn = turn === 'w' ? 'b' : 'w';
    
    gameHistory.push(getFEN());
    
    return { captured: !!captured, cst: mv.cst, pro: mv.pro };
}

function undoMove() {
    if (isOnline || hist.length < 2 || over || aiGo) return;
    clearPremove();
    for (let i = 0; i < 2 && hist.length; i++) {
        const h = hist.pop(); notation.pop(); gameHistory.pop();
        brd[h.mv.fr][h.mv.fc] = h.pc; brd[h.mv.tr][h.mv.tc] = h.cap;
        if (h.epCap) brd[isW(h.pc) ? h.mv.tr+1 : h.mv.tr-1][h.mv.tc] = h.epCap;
        if (h.mv.cst) {
            const row = h.mv.tr;
            if (h.mv.cst === 'k') { brd[row][7] = brd[row][5]; brd[row][5] = ''; }
            else { brd[row][0] = brd[row][3]; brd[row][3] = ''; }
        }
        capW = h.capW; capB = h.capB; ep = h.ep; castle = h.castle; turn = turn === 'w' ? 'b' : 'w';
    }
    lastMv = hist.length ? hist[hist.length-1].mv : null;
    sel = null; moves = []; updUI(); draw();
}

// ========== UI ==========
function draw() {
    const board = document.getElementById('board');
    board.innerHTML = '';
    const kPos = findKing(turn === 'w'), check = inCheck(turn === 'w');
    
    for (let i = 0; i < 64; i++) {
        let r = Math.floor(i / 8), c = i % 8;
        if (flipped) { r = 7 - r; c = 7 - c; }
        
        const sq = document.createElement('div');
        sq.className = 'sq ' + ((r + c) % 2 ? 'b' : 'w');
        sq.dataset.r = r;
        sq.dataset.c = c;
        
        if (sel && sel.r === r && sel.c === c) sq.classList.add('sel');
        if (lastMv && ((lastMv.fr === r && lastMv.fc === c) || (lastMv.tr === r && lastMv.tc === c))) sq.classList.add('lm');
        if (check && kPos && kPos.r === r && kPos.c === c) sq.classList.add('ch');
        
        if (premove) {
            if (premove.from.r === r && premove.from.c === c) sq.classList.add('premove-from');
            if (premove.to.r === r && premove.to.c === c) sq.classList.add('premove-to');
        }
        
        for (let j = 0; j < moves.length; j++) {
            if (moves[j].tr === r && moves[j].tc === c) {
                sq.classList.add(brd[r][c] ? 'cap' : 'dot');
                break;
            }
        }
        
        if (brd[r][c]) {
            const piece = document.createElement('span');
            piece.className = 'piece';
            piece.textContent = PIECES[brd[r][c]];
            sq.appendChild(piece);
        }
        
        sq.addEventListener('click', function() { onClick(parseInt(this.dataset.r), parseInt(this.dataset.c)); });
        board.appendChild(sq);
    }
    updCaptured(); updMoves(); updateTimerDisplay();
}

function onClick(r, c) {
    const isMyTurn = (turn === 'w') === playerColor;
    const pc = brd[r][c];
    
    if (premove) {
        clearPremove();
        draw();
        return;
    }
    
    if (!isMyTurn && !over) {
        if (sel) {
            if (sel.r === r && sel.c === c) {
                sel = null; moves = []; draw();
                return;
            }
            setPremove(sel.r, sel.c, r, c);
            return;
        }
        
        if (pc && isW(pc) === playerColor) {
            sel = { r, c };
            moves = getMoves(r, c, false);
            draw();
        }
        return;
    }
    
    if (over) return;
    
    if (sel) {
        let mv = null;
        for (let i = 0; i < moves.length; i++) {
            if (moves[i].tr === r && moves[i].tc === c) { mv = moves[i]; break; }
        }
        if (mv) {
            if (mv.pro) { showPromo(mv); return; }
            execMove(mv);
            return;
        }
    }
    
    if (pc && isW(pc) === (turn === 'w')) {
        sel = { r, c }; moves = getMoves(r, c);
    } else {
        sel = null; moves = [];
    }
    draw();
}

function execMove(mv, promo) {
    if (!promo) promo = 'q';
    const wasWhite = turn === 'w';
    const res = doMove(mv, promo);
    sel = null; moves = [];
    playMoveSound(mv, res);
    addIncrement(wasWhite);
    
    if (isOnline) sendData({ type: 'move', mv: { fr:mv.fr, fc:mv.fc, tr:mv.tr, tc:mv.tc, cst:mv.cst, pro:mv.pro, isEp:mv.isEp, dbl:mv.dbl, promo } });
    
    updUI(); draw();
    if (checkEnd()) return;
    
    if (!isOnline) {
        aiGo = true; updUI();
        setTimeout(aiMove, 200);
    }
}

function playMoveSound(mv, res) {
    if ((res && res.pro) || mv.pro) playSound('sndPromo');
    else if ((res && res.cst) || mv.cst) playSound('sndCastle');
    else if ((res && res.captured) || (brd[mv.tr] && brd[mv.tr][mv.tc])) playSound('sndCapture');
    else playSound('sndMove');
    setTimeout(function() { if (inCheck(turn === 'w')) playSound('sndCheck'); }, 50);
}

function showPromo(mv) {
    const modal = document.getElementById('promoModal');
    const opts = document.getElementById('promoOpts');
    opts.innerHTML = '';
    const isWhite = turn === 'w';
    const pcs = isWhite ? ['Q','R','B','N'] : ['q','r','b','n'];
    pcs.forEach(function(p) {
        const div = document.createElement('div');
        div.className = 'promo-opt';
        div.textContent = PIECES[p];
        div.addEventListener('click', function() {
            modal.classList.remove('show');
            execMove(mv, p.toLowerCase());
        });
        opts.appendChild(div);
    });
    modal.classList.add('show');
}

function checkEnd() {
    if (allMoves(turn === 'w').length === 0) {
        over = true; stopTimer();
        const check = inCheck(turn === 'w');
        const win = check && (turn === 'w') !== playerColor;
        showEnd(check ? (win ? 'win' : 'lose') : 'draw', check ? '–ú–∞—Ç' : '–ü–∞—Ç');
        return true;
    }
    return false;
}

function showEnd(res, msg) {
    playSound('sndEnd');
    const icons = { win: 'üèÜ', lose: 'üò¢', draw: 'ü§ù' };
    const titles = { win: '–ü–æ–±–µ–¥–∞!', lose: '–ü–æ—Ä–∞–∂–µ–Ω–∏–µ', draw: '–ù–∏—á—å—è' };
    document.getElementById('endIcon').textContent = icons[res];
    document.getElementById('endTitle').textContent = titles[res];
    document.getElementById('endMsg').textContent = msg;
    document.getElementById('endModal').classList.add('show');
}

function updUI() {
    const isMyTurn = (turn === 'w') === playerColor;
    document.getElementById('bottomPlayer').classList.toggle('active', isMyTurn && !over);
    document.getElementById('topPlayer').classList.toggle('active', !isMyTurn && !over);
    
    let status = '–í–∞—à —Ö–æ–¥';
    if (over) status = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
    else if (isOnline) status = isMyTurn ? '–í–∞—à —Ö–æ–¥' : '–•–æ–¥ ' + opponentNick + '...';
    else if (aiGo) status = '–ò–ò –¥—É–º–∞–µ—Ç...';
    document.getElementById('status').textContent = status;
}

function updCaptured() {
    const ord = p => ({q:0,r:1,b:2,n:3,p:4})[p.toLowerCase()] || 5;
    const render = a => a.slice().sort((x,y) => ord(x)-ord(y)).map(p => PIECES[p]).join('');
    document.getElementById(flipped ? 'topCaptured' : 'bottomCaptured').innerHTML = render(capB);
    document.getElementById(flipped ? 'bottomCaptured' : 'topCaptured').innerHTML = render(capW);
}

function updMoves() {
    let h = '';
    for (let i = 0; i < notation.length; i += 2) {
        h += '<span><span class="mp">' + (i/2+1) + '.</span>' + notation[i] + (notation[i+1] ? ' '+notation[i+1] : '') + ' </span>';
    }
    document.getElementById('movesList').innerHTML = h;
}

// ========== –ò–ò ==========
function aiMove() {
    if (over) return;
    const best = findBest();
    if (best) {
        doMove(best, 'q');
        playMoveSound(best, { captured: !!(brd[best.tr] && brd[best.tr][best.tc]), cst: best.cst });
        addIncrement(turn === 'b');
    }
    aiGo = false; updUI(); draw();
    if (!checkEnd() && premove) setTimeout(executePremove, 100);
}

function findBest() {
    const isAiW = !playerColor;
    let mvs = allMoves(isAiW);
    if (!mvs.length) return null;
    
    const depth = settings.elo < 800 ? 1 : settings.elo < 1500 ? 2 : settings.elo < 2200 ? 3 : 4;
    const rand = Math.max(5, 70 - settings.elo / 40);
    
    mvs = mvs.map(mv => {
        let sc = 0;
        const tg = brd[mv.tr][mv.tc];
        if (tg) sc += VAL[tg.toLowerCase()] * 10;
        if (mv.pro) sc += 800;
        if (mv.cst) sc += 60;
        sc += (3.5 - Math.abs(mv.tc - 3.5)) * 8 + (3.5 - Math.abs(mv.tr - 3.5)) * 5;
        if (notation.length < 6) sc += Math.random() * 50;
        return { mv, sc };
    }).sort((a, b) => b.sc - a.sc).map(x => x.mv);
    
    let best = mvs[0], bestSc = -Infinity;
    for (let i = 0; i < mvs.length; i++) {
        const mv = mvs[i];
        const st = save();
        doMove(mv, 'q');
        const sc = -minimax(depth - 1, -Infinity, Infinity, !isAiW) + (Math.random() - 0.5) * rand;
        restore(st);
        if (sc > bestSc) { bestSc = sc; best = mv; }
    }
    return best;
}

function minimax(d, a, b, isMax) {
    if (d === 0) return evaluate();
    const mvs = allMoves(isMax);
    if (!mvs.length) return inCheck(isMax) ? (isMax ? -15000 : 15000) : 0;
    
    if (isMax) {
        let max = -Infinity;
        for (let i = 0; i < mvs.length; i++) {
            const st = save();
            doMove(mvs[i], 'q');
            const sc = minimax(d - 1, a, b, false);
            restore(st);
            if (sc > max) max = sc;
            if (sc > a) a = sc;
            if (b <= a) break;
        }
        return max;
    } else {
        let min = Infinity;
        for (let i = 0; i < mvs.length; i++) {
            const st = save();
            doMove(mvs[i], 'q');
            const sc = minimax(d - 1, a, b, true);
            restore(st);
            if (sc < min) min = sc;
            if (sc < b) b = sc;
            if (b <= a) break;
        }
        return min;
    }
}

const PST = {
    p: [[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,25,25,10,5,5],[0,0,0,20,20,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-20,-20,10,10,5],[0,0,0,0,0,0,0,0]],
    n: [[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
    b: [[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,10,10,10,10,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,5,10,10,5,0,-10],[-10,0,5,5,5,5,0,-10],[-10,0,0,0,0,0,0,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
    r: [[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
    q: [[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
    k: [[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-20,-30,-30,-40,-40,-30,-30,-20],[-10,-20,-20,-20,-20,-20,-20,-10],[20,20,0,0,0,0,20,20],[20,30,10,0,0,10,30,20]]
};

function evaluate() {
    let sc = 0;
    for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = brd[r][c]; if (!p) continue;
        const w = isW(p), t = p.toLowerCase();
        let v = VAL[t] || 0;
        if (PST[t]) v += PST[t][w ? r : 7-r][c];
        sc += w ? v : -v;
    }
    return sc;
}

function save() {
    return {
        brd: brd.map(r => r.slice()),
        turn, ep: ep ? {...ep} : null,
        castle: {...castle},
        capW: capW.slice(), capB: capB.slice(),
        notation: notation.slice(),
        histLen: hist.length,
        gameHistory: gameHistory.slice()
    };
}

function restore(s) {
    brd = s.brd.map(r => r.slice());
    turn = s.turn;
    ep = s.ep ? {...s.ep} : null;
    castle = {...s.castle};
    capW = s.capW.slice();
    capB = s.capB.slice();
    notation = s.notation.slice();
    gameHistory = s.gameHistory.slice();
    while (hist.length > s.histLen) hist.pop();
}

// ========== STOCKFISH –ê–ù–ê–õ–ò–ó ==========
function initStockfish() {
    try {
        stockfish = new Worker('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
        stockfish.postMessage('uci');
        stockfish.onmessage = function(e) {
            if (e.data === 'uciok') {
                console.log('Stockfish –≥–æ—Ç–æ–≤');
                stockfish.postMessage('isready');
            }
        };
    } catch (e) {
        console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Stockfish:', e);
        stockfish = null;
    }
}

function startAnalysis() {
    if (notation.length === 0) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ö–æ–¥!');
        return;
    }
    
    if (!stockfish) {
        alert('Stockfish –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
        return;
    }
    
    document.getElementById('analysisModal').classList.add('show');
    document.getElementById('analysisContent').innerHTML = `
        <div class="analysis-progress">
            <div>–ê–Ω–∞–ª–∏–∑ –ø–∞—Ä—Ç–∏–∏...</div>
            <div id="analysisProgressText">0 / ${notation.length}</div>
            <div class="analysis-progress-bar">
                <div class="analysis-progress-fill" id="analysisProgressBar" style="width:0%"></div>
            </div>
        </div>
    `;
    
    analyzeGame();
}

async function analyzeGame() {
    const totalMoves = notation.length;
    const evaluations = [];
    const classifications = [];
    
    for (let i = 0; i < totalMoves; i++) {
        const fen = gameHistory[i];
        const nextFen = gameHistory[i + 1];
        
        document.getElementById('analysisProgressText').textContent = `${i + 1} / ${totalMoves}`;
        document.getElementById('analysisProgressBar').style.width = ((i + 1) / totalMoves * 100) + '%';
        
        const evalBefore = await getStockfishEval(fen, 12);
        const evalAfter = await getStockfishEval(nextFen, 12);
        
        evaluations.push({ before: evalBefore, after: evalAfter });
        
        const isWhiteMove = i % 2 === 0;
        const classification = classifyMove(evalBefore, evalAfter, isWhiteMove);
        classifications.push(classification);
        
        await new Promise(r => setTimeout(r, 50));
    }
    
    showAnalysisResults(evaluations, classifications);
}

function getStockfishEval(fen, depth) {
    return new Promise((resolve) => {
        if (!stockfish) {
            resolve(0);
            return;
        }
        
        let resolved = false;
        let bestScore = 0;
        
        const handler = function(e) {
            const line = e.data;
            
            if (typeof line === 'string') {
                if (line.includes('score cp')) {
                    const match = line.match(/score cp (-?\d+)/);
                    if (match) {
                        bestScore = parseInt(match[1]);
                        if (fen.includes(' b ')) bestScore = -bestScore;
                    }
                }
                
                if (line.includes('score mate')) {
                    const match = line.match(/score mate (-?\d+)/);
                    if (match) {
                        const mateIn = parseInt(match[1]);
                        bestScore = mateIn > 0 ? 10000 - mateIn * 10 : -10000 - mateIn * 10;
                        if (fen.includes(' b ')) bestScore = -bestScore;
                    }
                }
                
                if (line.startsWith('bestmove') && !resolved) {
                    resolved = true;
                    stockfish.removeEventListener('message', handler);
                    resolve(bestScore);
                }
            }
        };
        
        stockfish.addEventListener('message', handler);
        stockfish.postMessage('position fen ' + fen);
        stockfish.postMessage('go depth ' + depth);
        
        setTimeout(() => {
            if (!resolved) {
                resolved = true;
                stockfish.removeEventListener('message', handler);
                resolve(bestScore);
            }
        }, 5000);
    });
}

function classifyMove(evalBefore, evalAfter, isWhiteMove) {
    const diff = isWhiteMove ? (evalAfter - evalBefore) : (evalBefore - evalAfter);
    
    if (diff >= 50) {
        return { class: 'brilliant', symbol: '!!', color: '#1baca6' };
    } else if (diff >= 20) {
        return { class: 'great', symbol: '!', color: '#5c8bb0' };
    } else if (diff >= -10) {
        return { class: 'best', symbol: '‚úì', color: '#81b64c' };
    } else if (diff >= -25) {
        return { class: 'good', symbol: '', color: '#96bc4b' };
    } else if (diff >= -50) {
        return { class: 'inaccuracy', symbol: '?!', color: '#f7c631' };
    } else if (diff >= -150) {
        return { class: 'mistake', symbol: '?', color: '#e58f2a' };
    } else {
        return { class: 'blunder', symbol: '??', color: '#ca3431' };
    }
}

function showAnalysisResults(evaluations, classifications) {
    const stats = {
        white: { brilliant: 0, great: 0, best: 0, good: 0, inaccuracy: 0, mistake: 0, blunder: 0 },
        black: { brilliant: 0, great: 0, best: 0, good: 0, inaccuracy: 0, mistake: 0, blunder: 0 }
    };
    
    classifications.forEach((c, i) => {
        const side = i % 2 === 0 ? 'white' : 'black';
        stats[side][c.class]++;
    });
    
    const calcAccuracy = (s) => {
        const total = s.brilliant + s.great + s.best + s.good + s.inaccuracy + s.mistake + s.blunder;
        if (total === 0) return 0;
        const score = s.brilliant * 100 + s.great * 95 + s.best * 90 + s.good * 80 + s.inaccuracy * 60 + s.mistake * 30 + s.blunder * 0;
        return Math.round(score / total);
    };
    
    const whiteAccuracy = calcAccuracy(stats.white);
    const blackAccuracy = calcAccuracy(stats.black);
    
    const finalEval = evaluations.length > 0 ? evaluations[evaluations.length - 1].after : 0;
    const whitePercent = Math.max(5, Math.min(95, 50 + finalEval / 20));
    
    let html = `
        <div class="analysis-bar" style="--white-percent: ${whitePercent}%">
            <span class="analysis-bar-label white">${finalEval > 0 ? '+' : ''}${(finalEval/100).toFixed(1)}</span>
            <span class="analysis-bar-label black"></span>
        </div>
        
        <div class="accuracy-box">
            <div class="accuracy-item">
                <div class="accuracy-value">${whiteAccuracy}%</div>
                <div class="accuracy-label">‚¨ú –ë–µ–ª—ã–µ</div>
            </div>
            <div class="accuracy-item">
                <div class="accuracy-value">${blackAccuracy}%</div>
                <div class="accuracy-label">‚¨õ –ß—ë—Ä–Ω—ã–µ</div>
            </div>
        </div>
        
        <div class="classification-stats">
            ${stats.white.brilliant + stats.black.brilliant > 0 ? `<span class="class-stat class-brilliant">!! ${stats.white.brilliant + stats.black.brilliant}</span>` : ''}
            ${stats.white.great + stats.black.great > 0 ? `<span class="class-stat class-great">! ${stats.white.great + stats.black.great}</span>` : ''}
            ${stats.white.best + stats.black.best > 0 ? `<span class="class-stat class-best">‚úì ${stats.white.best + stats.black.best}</span>` : ''}
            ${stats.white.inaccuracy + stats.black.inaccuracy > 0 ? `<span class="class-stat class-inaccuracy">?! ${stats.white.inaccuracy + stats.black.inaccuracy}</span>` : ''}
            ${stats.white.mistake + stats.black.mistake > 0 ? `<span class="class-stat class-mistake">? ${stats.white.mistake + stats.black.mistake}</span>` : ''}
            ${stats.white.blunder + stats.black.blunder > 0 ? `<span class="class-stat class-blunder">?? ${stats.white.blunder + stats.black.blunder}</span>` : ''}
        </div>
        
        <div class="moves-analysis">
    `;
    
    for (let i = 0; i < notation.length; i++) {
        const c = classifications[i];
        const moveNum = Math.floor(i / 2) + 1;
        const isWhite = i % 2 === 0;
        const evalVal = evaluations[i] ? evaluations[i].after : 0;
        
        html += `
            <div class="move-analysis-item">
                <span class="move-number">${isWhite ? moveNum + '.' : ''}</span>
                <span class="move-notation">${isWhite ? '‚¨ú' : '‚¨õ'} ${notation[i]}</span>
                <span class="move-eval">${evalVal > 0 ? '+' : ''}${(evalVal/100).toFixed(1)}</span>
                <span class="move-class" style="color:${c.color}">${c.symbol}</span>
            </div>
        `;
    }
    
    html += '</div>';
    
    document.getElementById('analysisContent').innerHTML = html;
}
</script>
</body>
</html>
